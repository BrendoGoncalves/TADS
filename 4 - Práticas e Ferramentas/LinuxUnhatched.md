 **Bem-vindos!**

Olá, e bem-vindos ao módulo NDG Linux Unhatched! Estamos muito entusiasmados em oferecer-lhe esta breve introdução ao mundo do Linux. Antes de começar, gostaríamos de aproveitar a oportunidade para explicar a intenção e o objetivo deste módulo.

Não se preocupe se você tem pouca ou nenhuma experiência no Linux. Este módulo foi projetado como uma introdução para alunos iniciantes sem treinamento anterior do Linux. Se você achar este material útil, você pode considerar continuar com nosso NDG Linux Essentials ou NDG Introduction to Linux cursos para desenvolver conhecimentos adicionais. Informações adicionais sobre esses cursos podem ser encontradas no final deste módulo.

Como você já deve estar ciente, o kernel Linux encontrou seu caminho em um número incrível de sistemas diversos. Agora, este sistema pode ser encontrado em tudo, desde automóveis a foguetes, relógios a televisores e netbooks aos supercomputadores mais rápidos. O Linux representa apenas uma porcentagem relativamente pequena dos sistemas operacionais encontrados em computadores desktop, mas ganhou uso generalizado em servidores, dispositivos de Internet das Coisas (IoT), equipamentos de rede, smartphones e muitos outros dispositivos que você pode não pensar como sendo mesmo computadores. A partir do roteador doméstico que fornece sua conexão com a Internet ao servidor em que este curso está hospedado, é provável que vários dispositivos com Linux estejam permitindo que você leia esta página.

Esperamos que você ache o módulo NDG Linux Unhatched útil. Parabéns por dar seus primeiros passos no mundo do Linux!

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Por que aprender Linux?**

O campo da Tecnologia da Informação (TI) está cheio de oportunidades. Para indivíduos que desejam seguir uma carreira em TI, um dos maiores desafios pode ser decidir como começar. Muitas vezes, as pessoas estão motivadas a aprender novas habilidades que lhes permitirão buscar oportunidades maiores e melhores tanto na sua vida pessoal como profissional. Aprender uma nova habilidade requer tempo e disciplina, mas com a motivação certa, não precisa ser doloroso. Nesta seção, discutiremos por que o tempo e o esforço que você investir no aprendizado do Linux serão benéficos para você; e lembre-se, todos que trabalham em TI tiveram que começar em algum lugar.

Aprender Linux é uma ótima maneira de começar! Por que o Linux é uma habilidade importante para aprender no mundo orientado pela tecnologia de hoje?

O que é Linux?

Antes de determinarmos o que torna o Linux um recurso tão grande para o seu conjunto de habilidades, vamos defini-lo primeiro. Linux é um software de sistema operacional que é executado em um sistema de computador de hardware. Um sistema operacional é um software que permite que outros programas, como processadores de texto e navegadores web, sejam instalados e executados em um computador.

Seu celular, tablet, laptop e desktop precisam de um sistema operacional para executar o software (geralmente chamado de aplicativos) que você deseja usar. Isso significa que o Linux não se limita a apenas desktops e laptops, e vamos expandir isso à medida que continuamos nossa discussão.

A principal razão pela qual aprender Linux é útil, é que Linux é usado em quase todos os lugares! O Linux é usado em computadores desktop e laptop, servidores web, dispositivos móveis (Android), tecnologia de nuvem pública (ou seja, Google, Amazon, etc), Chromebooks e redes (ou seja, Cisco Networks). Embora você nunca tenha usado o Linux em um desktop ou laptop, é provável que você esteja usando outra tecnologia que seja executada no Linux, como um celular rodando o Android, um tablet ou sites populares como Facebook, Twitter e Amazon. Na verdade, estima-se que os servidores que executam Linux geram mais da metade das páginas web na internet.

Quem pode usar o Linux?

Você pode ter ouvido falar do Linux e pensou que apenas indivíduos tecnologicamente avançados estão usando-o para programar, desenvolver ou até mesmo hacking! Embora seja verdade que muitos técnicos usam Linux, isso não significa que o Linux seja muito difícil de aprender ou não seja útil para iniciantes.

Na verdade, entender o Linux, especialmente a interface de linha de comando do Linux, ajudará você a entender melhor a computação enquanto lhe dá habilidades básicas de computação que você pode usar em uma carreira futura.

Para entender por que as habilidades do Linux são únicas, vamos examinar a interface gráfica do usuário (GUI). Esta é a interface que você provavelmente está usando em seu smartphone, tablet ou computador hoje. Uma GUI exibe ícones e imagens que você pode selecionar para dizer ao dispositivo o que deseja fazer ou usar. Atrás da GUI, está um código que um programador desenvolveu. Quando você clica em um ícone ou pasta em uma GUI, ele envia um comando para o código dizendo ao sistema o que fazer.
Imagem de uma interface gráfica do usuário com a janela do gerenciador de arquivos e pastas de arquivos

Os desktops Linux usam uma GUI, mas também tem uma ferramenta mais eficiente para realizar as mesmas ações que uma GUI, a interface de linha de comando (CLI).
Imagem de comandos sendo digitados em um terminal em um prompt de linha de comando

A linha de comando do Linux é uma interface baseada em texto que aceita comandos digitados nela. Esses comandos fazem com que uma ação seja executada no sistema operacional do computador. Claro, janelas e ícones são fáceis de usar, no entanto, a linha de comando é muitas vezes o herói quando se trata de administração do sistema e solução de problemas, uma vez que dá uma imagem clara do que o sistema está fazendo em qualquer momento.

Tudo isso considerado, por que aprender Linux é um bom começo para alguém que considera uma carreira em TI? Como dito anteriormente, o uso do Linux é generalizado e continua a crescer em todas as áreas da tecnologia. O que empresas e organizações como NASA, McDonald's, New York Stock Exchange (NYSE), DreamWorks Animation e o Departamento de Defesa dos EUA têm em comum? Sim, você adivinhou corretamente, todos eles usam Linux.

Essas empresas têm algo mais em comum, pois reconhecem que investir em tecnologia é importante em um mundo que está ansioso por adotar novas tecnologias para inovar e resolver problemas. A proliferação da tecnologia em quase todos os aspectos da vida resolveu muitos problemas, mas também criou novos desafios. Por exemplo, agora que quase tudo pode ser feito on-line, estamos criando dados digitais a uma taxa rápida, o que está criando uma demanda por esses dados. As habilidades técnicas para analisar, processar, proteger e transmitir dados também estão em alta demanda. O aprendizado do Linux pode ajudá-lo na jornada para adquirir essas habilidades. Veja a seguir alguns exemplos de algumas profissões de TI que exigem conhecimento de habilidades em Linux:

    Engenharia de rede - Os engenheiros de rede são responsáveis pelo gerenciamento dos computadores da rede usados para transmitir dadosO conhecimento do Linux é fundamental para os engenheiros de rede, já que mais da metade dos servidores do mundo são baseados em Linux. A maioria dos sistemas operacionais de rede são baseados em uma variação do Linux.

    cibersegurança - Profissionais de cibersegurança monitoram e investigam ameaças de segurança aos dados em sistemas. Linux é usado em cibersegurança para realizar testes de penetração do sistema e avaliar a vulnerabilidade de um sistema.

    Desenvolvimento/Programação - Desenvolvedores e programadores projetam aplicativos de computador. A linha de comando do Linux permite que desenvolvedores e programadores criem scripts; uma função que permite que um usuário coloque comandos juntos para executar ações complexas em um computador. Linux também é usado neste campo porque somente Linux permite que os usuários acessem seu código-fonte, dando aos usuários a capacidade de experimentar o código e aprender fazendo.

    Análise de Dados - Analistas de dados e cientistas classificam e analisam conjuntos de dados para encontrar padrões para relatar e prever tendências e comportamentos. Os analistas de dados usam o Linux devido à grande variedade de ferramentas e comandos disponíveis para análise de dados, como MySQL e muito mais.

Os sistemas operacionais Linux vêm em muitas formas. Há uma variedade de distribuições disponíveis para atender às necessidades e demandas de muitos setores de TI. Por exemplo, os profissionais de cibersegurança podem usar o Linux Kali, os desenvolvedores podem usar o Linux Ubuntu, os usuários regulares podem usar o Linux Mint e os servidores corporativos podem ser executados no Red Hat Enterprise Linux.

Considere isto
As habilidades do Linux são necessárias para muitas faixas profissionais de TI. Por exemplo, o conhecimento de comandos básicos do Linux é um pré-requisito para programas de certificação de TI, como a popular certificação Cisco Certified CyberOps Associate. Para saber mais sobre como o Linux se aplica ao Cisco Certified CyberOps Associate, visite a seção no final deste curso chamada Linux for Cisco Certified CyberOps Associate.

Algumas outras grandes razões para usar e aprender Linux são que, em muitos casos, é gratuito, fácil de instalar, open source, e há uma comunidade Linux ativa disponível para suporte. Isso permite que os iniciantes que querem começar a aumentar suas habilidades de TI comecem a usar o Linux facilmente.

Como você pode ver, há muitas razões para aprender e explorar o Linux!

------------------------------------------------------------------------------------------------------------------------------------------------------

 **Sintaxe de Comando Básico**

Este módulo trata exclusivamente da CLI ou da interface de linha de comando, em vez de uma GUI ou interface gráfica do usuário que você possa estar familiarizado. O terminal CLI é uma ferramenta poderosa que frequentemente é o principal método usado para administrar pequenos dispositivos de baixo consumo de energia, servidores de computação em nuvem extremamente capazes e tudo o que há entre eles. Uma compreensão básica do terminal é essencial para diagnosticar e corrigir a maioria dos sistemas baseados em Linux. Como o Linux agora se tornou tão onipresente, mesmo aqueles que planejam trabalhar principalmente com sistemas que não utilizam o kernel Linux podem se beneficiar de ter uma compreensão básica do terminal.

O que é um comando? Um comando é um programa de software que, quando executado na CLI (interface de linha de comando), executa uma ação no computador. Quando você digita um comando, um processo é executado pelo sistema operacional que pode ler o input, manipular dados e produzir output. Um comando executa um processo no sistema operacional, que faz com que o computador execute um trabalho.

Para executar um comando, o primeiro passo é digitar o nome do comando. Clique no terminal à direita. Digite ls (letras minúsculas L e S) e pressione Enter. O resultado deve ser semelhante ao exemplo abaixo:

sysadmin@localhost:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

O nome do comando geralmente é baseado no que ele faz ou no que o desenvolvedor que criou o comando acha que descreve melhor a função do comando. Por exemplo, o comando ls exibe uma lista de informações sobre arquivos. Associar o nome do comando com algo mnemônico para o que ele faz pode ajudá-lo a lembrar os comandos mais facilmente.

Considere isto

Cada parte do comando é normalmente sensível a maiúsculas e minúsculas, então LS está incorreto e falhará, mas ls está correto e será executado.

sysadmin@localhost:~$ LS
-bash: /usr/games/LS: Permission denied

A maioria dos comandos segue um padrão simples de sintaxe:

comando [opcoes…] [argumentos…]

Em outras palavras, você digita um comando, seguido de quaisquer opções e/ou argumentos antes de pressionar a tecla Enter. Normalmente, as opções alteram o comportamento do comando e os argumentos são itens ou valores para o comando agir. Embora existam alguns comandos no Linux que não são inteiramente consistentes com essa sintaxe, a maioria dos comandos usam essa sintaxe ou algo semelhante.

No exemplo acima, o comando ls foi executado sem opções ou argumentos. Quando este for o caso, seu comportamento padrão é retornar uma lista de arquivos contidos no diretório atual.

sysadmin@localhost:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Argumentos**

comando [opcoes…] [argumentos…]

Um argumento pode ser usado para especificar algo para o comando agir. O comando ls pode ser dado o nome de um diretório como um argumento, e ele irá listar o conteúdo desse diretório. No próximo exemplo, o diretório Documents será usado como um argumento:

sysadmin@localhost:~$ ls Documents
School           alpha-second.txt  food.txt     linux.txt     os.csv
Work             alpha-third.txt   hello.sh     longfile.txt  people.csv
adjectives.txt   alpha.txt         hidden.txt   newhome.txt   profile.txt
alpha-first.txt  animals.txt       letters.txt  numbers.txt   red.txt

A saída resultante é uma lista de arquivos contidos no diretório Documents.

Como o Linux é de código aberto, existem alguns segredos interessantes que foram adicionados pelos desenvolvedores. Por exemplo, o comando aptitude é uma ferramenta de gerenciamento de pacotes disponível em algumas distribuições Linux. Este comando aceitará moo como argumento:

sysadmin@localhost:~$ aptitude moo  
There are no Easter Eggs in this program.

Há mais para este truque do que os olhos vêem, continue lendo!
Linux é código aberto. Linux é desenvolvido por uma comunidade, você visualiza e contribui com o código-fonte.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Opções**

comando [opcoes…] [argumentos…]

As opções podem ser usadas para alterar o comportamento de um comando. Na página anterior, o comando ls foi usado para listar o conteúdo de um diretório. No exemplo a seguir, a opção -l é fornecida ao comando ls, o que resulta em uma saída de “exibição longa”, o que significa que a saída fornece mais informações sobre cada um dos arquivos listados:

sysadmin@localhost:~$ ls -l
total 32
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Desktop                        
drwx------ 4 sysadmin sysadmin 4096 Dec 20  2017 Documents                      
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Downloads                      
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Music                          
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Pictures                       
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Public                         
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Templates                      
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Videos

Observe que, no comando acima, o -l é o "L" minúsculo.

Muitas vezes, o caractere é escolhido para ser mnemônico para o seu propósito, como escolher a letra l para longo ou r para reverso. Por padrão, o comando ls imprime os resultados em ordem alfabética, portanto, adicionar a opção -r irá imprimir os resultados em ordem alfabética inversa.

sysadmin@localhost:~$ ls -r
Videos  Templates  Public  Pictures  Music  Downloads  Documents  Desktop

Várias opções podem ser usadas de uma só vez, quer dadas como opções separadas como em -l -r ou combinadas como -lr. O resultado de todos esses exemplos seria o mesmo:

ls -l -r
ls -rl
ls -lr

Como explicado acima, -l fornece um formato de listagem longa enquanto -r reverte a listagem. O resultado do uso de ambas as opções é uma listagem longa dada em ordem inversa:

sysadmin@localhost:~$ ls -l -r
total 32
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Videos                         
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Templates                      
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Public                         
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Pictures                       
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Music                          
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Downloads                      
drwx------ 4 sysadmin sysadmin 4096 Dec 20  2017 Documents                      
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Desktop   
sysadmin@localhost:~$ ls -rl
total 32
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Videos                         
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Templates                      
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Public                         
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Pictures                       
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Music                          
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Downloads                      
drwx------ 4 sysadmin sysadmin 4096 Dec 20  2017 Documents                      
drwx------ 2 sysadmin sysadmin 4096 Dec 20  2017 Desktop 

Em última análise, os comandos podem usar muitas combinações de opções e argumentos. As possibilidades para cada comando serão únicas. Lembra-se da dica da aptitude?

sysadmin@localhost:~$ aptitude moo
There are no Easter Eggs in this program.

É possível alterar o comportamento deste comando usando opções. Veja o que acontece quando a opção -v (verbosa) é adicionada:

sysadmin@localhost:~$ aptitude -v moo
There really are no Easter Eggs in this program.

Ao combinar várias opções -v, podemos obter uma variedade de respostas:

sysadmin@localhost:~$ aptitude -vv moo
Didn't I already tell you that there are no Easter Eggs in this program?
sysadmin@localhost:~$ aptitude -vvv moo
Stop it!

Lembre-se que várias opções podem ser indicadas separadamente ou combinadas:

aptitude -v -v moo
aptitude -vv moo

Continue adicionando opções -v para ver quantas respostas únicas você pode obter!

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Impressão do Diretório de Trabalho**

Para descobrir onde você está atualmente localizado dentro do sistema de arquivos, o comando pwd pode ser usado. O comando pwd imprime o diretório de trabalho, sua localização atual dentro do sistema de arquivos:

pwd [OPÇÕES]

Considere isto

Não ligue a impressora ainda! Nos primeiros dias da computação, a saída da linha de comando seria enviada para impressoras físicas. Este método foi substituído por monitores de vídeo que poderiam exibir informações mais rapidamente. Nós ainda usamos a palavra print, mesmo que a saída esteja apenas sendo exibida em sua tela.

sysadmin@localhost:~$ pwd
/home/sysadmin

A saída do comando acima indica que o usuário está atualmente em sua pasta pessoal, mostrada no sistema de arquivos abaixo.
Sistema de arquivos mostrando o diretório root na parte superior e os diretórios abaixo, incluindo o diretório inicial. No diretório inicial está um diretório sysadmin destacado e os diretórios dentro do sysadmin (ou seja, Documents) mostrados abaixo

Considere isto

Observe que nossas máquinas virtuais empregam um prompt que exibe o diretório de trabalho atual, enfatizado com a cor azul. No primeiro prompt acima, o azul ~ é equivalente a /home/sysadmin, representando o diretório home do usuário.

sysadmin@localhost:~$

Depois de alterar diretórios (aprenderemos como fazer isso na próxima seção), a nova localização também pode ser confirmada no novo prompt, novamente mostrado em azul.

sysadmin@localhost:/etc/calendar$

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Alterando Diretórios**

Os arquivos são usados para armazenar dados tais como texto, gráficos e programas. Os diretórios são um tipo de arquivo usado para armazenar outros arquivos- eles fornecem uma estrutura organizacional hierárquica. A imagem abaixo mostra uma versão abreviada da estrutura do sistema de arquivos nas máquinas virtuais.
Hierarquia do sistema de arquivos com diretório root no topo. Sem diretórios destacados.

Ao iniciar uma nova máquina virtual, seja abrindo o curso ou depois de usar o botão reset (de redefinição), você está conectado como o usuário sysadmin em seu diretório pessoal, destacado abaixo:
Sistema de arquivos mostrando o diretório raiz na parte superior e os diretórios abaixo, incluindo o diretório inicial. No diretório inicial está um diretório sysadmin destacado e os diretórios dentro do sysadmin (ou seja, Documentos) mostrados abaixo.

Para navegar pela estrutura do sistema de arquivos, use o comando cd (change directory) para alterar diretórios.

cd [opções] [caminho]

Se você olhar novamente para o gráfico acima, você verá que o diretório Documents está localizado dentro do diretório home, onde você se encontra atualmente. Para mover para o diretório Documents, use-o como argumento para o comando cd:

sysadmin@localhost:~$ cd Documents                                              
sysadmin@localhost:~/Documents$ 

Os diretórios são equivalentes a pastas no Windows e Mac OS. Assim como esses sistemas operacionais mais populares, uma estrutura de diretórios Linux tem um nível superior. Não é chamado de “Meu Computador”, mas sim o diretório root (raiz) e é representado pelo caractere /. Para mover para o diretório root, use o caractere / como argumento para o comando cd.

sysadmin@localhost:~/Documents$ cd /
sysadmin@localhost:/$

Hierarquia do sistema de arquivos com diretório root destacado no topo.

O argumento para o comando cd é mais do que apenas o nome de um diretório, na verdade é um caminho. Um caminho é uma lista de diretórios separados pelo caractere /. Por exemplo, /home/sysadmin é o caminho para seu diretório home:
Hierarquia do sistema de arquivos com o diretório root destacado no topo, o diretório inicial destacado embaixo e o diretório sysadmin destacado no diretório inicial.

Se você pensar no sistema de arquivos como um mapa, os caminhos são as direções passo a passo; eles podem ser usados para indicar a localização de qualquer arquivo dentro do sistema de arquivos. Existem dois tipos de caminhos: absoluto e relativo. Os caminhos absolutos começam na root do sistema de arquivos, os caminhos relativos começam a partir da sua localização atual.
Caminhos Absolutos

Um caminho absoluto permite que você especifique a localização exata de um diretório. Ele sempre começa no diretório root, portanto ele sempre começa com o caractere /. O caminho para o diretório home /home/sysadmin é um caminho absoluto. O caminho começa no diretório root /, se move para o diretório home e, em seguida, para o diretório sysadmin. Seguindo esse caminho em uma interface gráfica do usuário (GUI) como seu computador doméstico seria algo parecido com isso:

Use este caminho como um argumento para o comando cd para voltar para o diretório home do usuário sysadmin.

sysadmin@localhost:/$ cd /home/sysadmin
sysadmin@localhost:~$

Nenhuma saída significa que o comando foi bem-sucedido. Vá em frente e confirme isso usando o comando pwd:

sysadmin@localhost:~$ pwd                                                       
/home/sysadmin

Caminhos Relativos

Um caminho relativo fornece direções para um arquivo relativo à sua localização atual no sistema de arquivos. Os caminhos relativos não começam com o caractere /, eles começam com o nome de um diretório. Dê outra olhada no primeiro exemplo de comando cd. O argumento é um exemplo do caminho relativo mais simples: o nome de um diretório em sua localização atual.

sysadmin@localhost:~$ cd Documents                                              
sysadmin@localhost:~/Documents$

Hierarquia do sistema de arquivos mostrando a root na parte superior e os diretórios abaixo, incluindo o diretório inicial. Diretório sysadmin realçado que representa a localização atual no diretório inicial. Caminho realçado para o diretório Documents no diretório sysadmin.

A imagem abaixo mostra um mapa dos arquivos contidos no diretório sysadmin. No momento, você está no diretório Documents e deseja mover para o diretório Art:
Hierarquia do sistema de arquivos mostrando o diretório sysadmin na parte superior, incluindo o diretório Documents realçado abaixo, bem como os diretórios abaixo do diretório Documents, incluindo o diretório School. O diretório Art destacado está localizado abaixo do diretório School.

Um caminho relativo começa a partir do diretório atual, no entanto você não o inclui no caminho. O primeiro passo seria mover para o diretório School e, em seguida, mover para o diretório Art. Use o caractere / para separar os nomes dos diretórios e o resultado School/Art é um caminho relativo do diretório Documents para o diretório Art:
Hierarquia do sistema de arquivos mostrando o diretório sysadmin no topo e um caminho relativo para o diretório Art.

Use o caminho relativo como um argumento para o comando cd para mover para o diretório Art.

sysadmin@localhost:~/Documents/$ cd School/Art
sysadmin@localhost:~/Documents/School/Art$

Use o comando pwd para confirmar a alteração:

sysadmin@localhost:~/Documents/School/Art$ pwd                                      
/home/sysadmin/Documents/School/Art

Considere isto
A saída do comando pwd é o caminho absoluto para o diretório Art.

Hierarquia do sistema de arquivos mostrando o diretório root no topo e um caminho relativo para o diretório Art.

Considere isto

No exemplo acima, o comando cd seguiu o caminho School/Art:

cd School/Art

Um caminho também pode ser dividido em vários comandos cd. O seguinte conjunto de comandos obteria os mesmos resultados:

cd School
cd Art

Atalhos

Os Caracteres ..

Independentemente do diretório em que você esteja, os caracteres .. sempre representa um diretório maior em relação ao diretório atual, às vezes referido como o diretório pai. Para mover do diretório Art de volta para o diretório School:

sysadmin@localhost:~/Documents/School/Art$ cd ..                                
sysadmin@localhost:~/Documents/School$

O Caractere .

Independentemente do diretório em que você esteja, o caractere . sempre representa seu diretório atual. Para o cd este atalho não é muito útil, mas será útil para comandos cobertos nas seções subsequentes.

O caractere ~

O diretório home do usuário atual é representado pelo caractere ~. Como mencionado acima, você sempre começa como o usuário sysadmin, cuja home está localizada em /home/sysadmin. Para retornar ao seu diretório home a qualquer momento, execute o seguinte comando:

sysadmin@localhost:~/Documents/School$ cd ~
sysadmin@localhost:~$

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Listando arquivos**

O comando ls é usado para listar o conteúdo de um diretório. Você já o viu sendo usado algumas vezes antes em exemplos, mas esta página ajudará a garantir que você esteja confortável com seu uso.

ls [OPÇÕES] [ARQUIVO]

Por padrão, quando o comando ls é usado sem opções ou argumentos, ele irá listar os arquivos no diretório atual:

sysadmin@localhost:~$ ls
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

Para saber os detalhes sobre um arquivo, tais como, o tipo de arquivo, as permissões, propriedade ou o carimbo de data/hora, execute uma listagem longa usando a opção -l para o comando ls. Abaixo, uma listagem do diretório /var/log é usada como um exemplo, uma vez que fornece uma variedade de saídas:

sysadmin@localhost:~$ ls -l /var/log/
total 844                                                                       
-rw-r--r-- 1 root   root  18047 Dec 20  2017 alternatives.log                   
drwxr-x--- 2 root   adm    4096 Dec 20  2017 apache2                            
drwxr-xr-x 1 root   root   4096 Dec 20  2017 apt                                
-rw-r----- 1 syslog adm    1346 Oct  2 22:17 auth.log                           
-rw-r--r-- 1 root   root  47816 Dec  7  2017 bootstrap.log                      
-rw-rw---- 1 root   utmp      0 Dec  7  2017 btmp                               
-rw-r----- 1 syslog adm     547 Oct  2 22:17 cron.log                           
-rw-r----- 1 root   adm   85083 Dec 20  2017 dmesg                              
-rw-r--r-- 1 root   root 325238 Dec 20  2017 dpkg.log                           
-rw-r--r-- 1 root   root  32064 Dec 20  2017 faillog                            
drwxr-xr-x 2 root   root   4096 Dec  7  2017 fsck                               
-rw-r----- 1 syslog adm     106 Oct  2 19:57 kern.log                           
-rw-rw-r-- 1 root   utmp 292584 Oct  2 19:57 lastlog                            
-rw-r----- 1 syslog adm   19573 Oct  2 22:57 syslog                             
drwxr-xr-x 2 root   root   4096 Apr 11  2014 upstart                            
-rw-rw-r-- 1 root   utmp    384 Oct  2 19:57 wtmp 

Cada linha corresponde a um arquivo contido no diretório. As informações podem ser divididas em campos separados por espaços. Os campos são os seguintes:

    Tipo de arquivo

    -rw-r--r-- 1 root   root  18047 Dec 20  2017 alternatives.log       
                
    drwxr-x--- 2 root   adm    4096 Dec 20  2017 apache2  

    Na verdade, o primeiro campo contém dez caracteres, onde o primeiro caractere indica o tipo de arquivo e os próximos nove especificam permissões. Os tipos de arquivo são:
    Símbolo 	Tipo de Arquivo 	Descrição
    d 	diretorio 	Um arquivo usado para armazenar outros arquivos.
    - 	arquivo regular 	Inclui arquivos legíveis, arquivos de imagens, arquivos binários e arquivos compactados.
    l 	link simbólico 	Aponta para outro arquivo.
    s 	tomada 	Permite a comunicação entre processos.
    p 	tubo 	Permite a comunicação entre processos.
    b 	bloquear arquivo 	Usado para se comunicar com o hardware.
    c 	arquivo de caracteres 	Usado para se comunicar com o hardware.

    O primeiro arquivo alternatives.log é um arquivo regular -, enquanto o segundo arquivo apache2 é um diretório d.

    Permissões

    drwxr-xr-x 2 root   root   4096 Apr 11  2014 upstart

    As permissões indicam como determinados usuários podem acessar um arquivo. Continue lendo para saber mais sobre permissões.

    Contagem de links físicos

    -rw-r----- 1 syslog adm    1346 Oct  2 22:17 auth.log

    Esse número indica quantos links rígidos apontam para esse arquivo. Links rígidos estão além do objetivo deste módulo, mas são abordados no curso NDG Linux Essentials.

    Proprietário do usuário

    -rw-r----- 1 syslog adm     106 Oct  2 19:57 kern.log

    O usuário syslog possui este arquivo. Toda vez que um arquivo é criado, a propriedade é automaticamente atribuída ao usuário que o criou.

    Proprietário do Grupo

    -rw-rw-r-- 1 root   utmp 292584 Oct  2 19:57 lastlog

    Indica qual grupo possui este arquivo.
    Tamanho do arquivo

    -rw-r----- 1 syslog adm   19573 Oct  2 22:57 syslog

    Diretórios e arquivos maiores podem ser mostrados em kilobytes, uma vez que exibir seu tamanho em bytes apresentaria um número muito grande. Portanto, no caso de um diretório, ele pode realmente ser um múltiplo do tamanho do bloco usado para o sistema de arquivos. O tamanho do bloco é o tamanho de uma série de dados armazenados no sistema de arquivos.
    Registro de data/hora

    drwxr-xr-x 2 root   root   4096 Dec  7  2017 fsck

    Isso indica a hora em que o conteúdo do arquivo foi modificado pela última vez.

    Nome do arquivo

    -rw-r--r-- 1 root   root  47816 Dec  7  2017 bootstrap.log

    O campo final contém o nome do arquivo ou diretório.

Considere isto

No caso de links simbólicos, um arquivo que aponta para outro arquivo, o nome do link será exibido junto com uma seta e o nome do caminho do arquivo original.

lrwxrwxrwx. 1 root root 22 Nov 6 2012 /etc/grub.conf -> ../boot/grub/grub.conf

Links simbólicos estão além do escopo deste módulo, mas são abordados no curso NDG Linux Essentials.
Organizando

Por padrão, a saída do comando ls é organizada alfabeticamente pelo nome do arquivo. Ele pode classificar por outros métodos também.

Acompanhe

As opções nos exemplos abaixo serão combinadas com a opção -l para que os detalhes relevantes dos arquivos sejam exibidos. Campos de aviso correspondentes à opção de pesquisa.

A opção -t irá classificar os arquivos por registro de data/hora:

sysadmin@localhost:~$ ls -lt /var/log                                           
total 844                                                                       
-rw-r----- 1 syslog adm   19573 Oct  2 22:57 syslog                             
-rw-r----- 1 syslog adm    1346 Oct  2 22:17 auth.log                           
-rw-r----- 1 syslog adm     547 Oct  2 22:17 cron.log                           
-rw-rw-r-- 1 root   utmp 292584 Oct  2 19:57 lastlog                            
-rw-rw-r-- 1 root   utmp    384 Oct  2 19:57 wtmp                               
-rw-r----- 1 syslog adm     106 Oct  2 19:57 kern.log                           
-rw-r--r-- 1 root   root  18047 Dec 20  2017 alternatives.log                   
-rw-r--r-- 1 root   root  32064 Dec 20  2017 faillog                            
-rw-r----- 1 root   adm   85083 Dec 20  2017 dmesg                              
-rw-r--r-- 1 root   root 325238 Dec 20  2017 dpkg.log                           
drwxr-x--- 2 root   adm    4096 Dec 20  2017 apache2                            
drwxr-xr-x 1 root   root   4096 Dec 20  2017 apt                                
-rw-r--r-- 1 root   root  47816 Dec  7  2017 bootstrap.log                      
drwxr-xr-x 2 root   root   4096 Dec  7  2017 fsck                               
-rw-rw---- 1 root   utmp      0 Dec  7  2017 btmp                               
drwxr-xr-x 2 root   root   4096 Apr 11  2014 upstart              

A opção -S ordenará os arquivos por tamanho de arquivo:

sysadmin@localhost:~$ ls -l -S /var/log                                         
total 844                                                                       
-rw-r--r-- 1 root   root 325238 Dec 20  2017 dpkg.log                           
-rw-rw-r-- 1 root   utmp 292584 Oct  2 19:57 lastlog                            
-rw-r----- 1 root   adm   85083 Dec 20  2017 dmesg                              
-rw-r--r-- 1 root   root  47816 Dec  7  2017 bootstrap.log                      
-rw-r--r-- 1 root   root  32064 Dec 20  2017 faillog                            
-rw-r----- 1 syslog adm   19573 Oct  2 22:57 syslog                             
-rw-r--r-- 1 root   root  18047 Dec 20  2017 alternatives.log                   
drwxr-x--- 2 root   adm    4096 Dec 20  2017 apache2                            
drwxr-xr-x 1 root   root   4096 Dec 20  2017 apt                                
drwxr-xr-x 2 root   root   4096 Dec  7  2017 fsck                               
drwxr-xr-x 2 root   root   4096 Apr 11  2014 upstart                            
-rw-r----- 1 syslog adm    1346 Oct  2 22:17 auth.log                           
-rw-r----- 1 syslog adm     547 Oct  2 22:17 cron.log                           
-rw-rw-r-- 1 root   utmp    384 Oct  2 19:57 wtmp                               
-rw-r----- 1 syslog adm     106 Oct  2 19:57 kern.log                           
-rw-rw---- 1 root   utmp      0 Dec  7  2017 btmp

A opção -r reverterá a ordem de qualquer tipo de classificação. Observe a diferença quando ela é adicionada ao exemplo anterior:

sysadmin@localhost:~$ ls -lSr /var/log
total 844                                                                       
-rw-rw---- 1 root   utmp      0 Dec  7  2017 btmp                               
-rw-r----- 1 syslog adm     106 Oct  2 19:57 kern.log                           
-rw-rw-r-- 1 root   utmp    384 Oct  2 19:57 wtmp                               
-rw-r----- 1 syslog adm     654 Oct  2 23:17 cron.log                           
-rw-r----- 1 syslog adm    1669 Oct  2 23:17 auth.log                           
drwxr-xr-x 2 root   root   4096 Apr 11  2014 upstart                            
drwxr-xr-x 2 root   root   4096 Dec  7  2017 fsck                               
drwxr-xr-x 1 root   root   4096 Dec 20  2017 apt                                
drwxr-x--- 2 root   adm    4096 Dec 20  2017 apache2                            
-rw-r--r-- 1 root   root  18047 Dec 20  2017 alternatives.log                   
-rw-r----- 1 syslog adm   19680 Oct  2 23:17 syslog                             
-rw-r--r-- 1 root   root  32064 Dec 20  2017 faillog                            
-rw-r--r-- 1 root   root  47816 Dec  7  2017 bootstrap.log                      
-rw-r----- 1 root   adm   85083 Dec 20  2017 dmesg                              
-rw-rw-r-- 1 root   utmp 292584 Oct  2 19:57 lastlog                            
-rw-r--r-- 1 root   root 325238 Dec 20  2017 dpkg.log        

Os números no campo de tamanho do arquivo mudam de decrescente para ascendente.

Usado sozinho a opção -r com lista os arquivos em ordem alfabética inversa:

sysadmin@localhost:~$ ls -r /var/log                                            
wtmp     lastlog   faillog   cron.log       auth.log  alternatives.log
upstart  kern.log  dpkg.log  btmp           apt
syslog   fsck      dmesg     bootstrap.log  apache2

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Acesso administrativo**

Existem muitos comandos Linux que lidam com informações confidenciais, como senhas, hardware do sistema, ou de outra forma operam sob outras circunstâncias excepcionais. Impedir que usuários regulares executem esses comandos ajuda a proteger o sistema. Fazer login como usuário root fornece acesso administrativo, permitindo a execução de alguns dos comandos privilegiados.
O Comando su

su OPÇÕES NOME_DO_USUÁRIO

O comando su permite que você atue temporariamente como um usuário diferente. Ele faz isso criando um novo shell. O shell é simplesmente um console de entrada de texto que permite digitar comandos. Por padrão, se uma conta de usuário não for especificada, o comando su abrirá um novo shell como usuário root, que fornece privilégios administrativos.

Acompanhar

A utilização da opção shell de login é recomendada, pois o shell de login configura totalmente o novo shell com as configurações do novo usuário. Esta opção pode ser especificada de uma das três maneiras:

su -
su -l
su --login

Depois de executar o comando su, uma senha é necessária. Em nossas máquinas virtuais, a senha para as contas root e sysadmin é netlab123. Se você esquecer, ele é exibido sempre que uma nova máquina virtual seja iniciada. Como medida de segurança, a senha não estará visível à medida que for digitada.

sysadmin@localhost:~$ su  -
Password:
root@localhost:~#

Observe que o prompt de comando foi alterado para refletir que você agora está conectado como usuário root. Para sair e retornar à conta sysadmin, use o comando exit. Note que o prompt muda novamente:

root@localhost:~# exit
logout
sysadmin@localhost:~$

Para evitar a execução de comandos sensíveis, configuramos o comando Locomotiva Steam, o comando sl, para exigir acesso administrativo. Se o comando for executado como sysadmin, ele falhará:

sysadmin@localhost:~$ sl
-bash: /usr/bin/sl: Permission denied

Use o comando su para alternar para a conta root e executar o comando sl com acesso administrativo:

sysadmin@localhost:~$ su  -
Password:
root@localhost:~# sl

 
                            (@@) (  ) (@)  ( )  @@    ()    @     O     @
                         (   )
                     (@@@@)
                  (    )

                (@@@)
            ====        ________                ___________
        _D _|  |_______/        \__I_I_____===__|_________|
         |(_)---  |   H\________/ |   |        =|___ ___|      _________________
         /     |  |   H  |  |     |   |         ||_| |_||     _|
        |      |  |   H  |__--------------------| [___] |   =|
        | ________|___H__/__|_____/[][]~\_______|       |   -|
        |/ |   |-----------I_____I [][] []  D   |=======|____|__________________
      __/ =| o |=-~~\  /~~\  /~~\  /~~\ ____Y___________|__|____________________
       |/-=|___|=    ||    ||    ||    |_____/~\___/          |_D__D__D_|  |_D__
        \_/      \_O=====O=====O=====O/      \_/               \_/   \_/    \_/

Use o comando exit novamente para retornar à conta sysadmin.

root@localhost:~# exit
logout
sysadmin@localhost:~$

O Comando sudo

sudo [OPTIONS] COMANDO

O comando sudo permite que um usuário execute um comando como outro usuário sem criar um novo shell. Em vez disso, para executar um comando com privilégios administrativos, use-o como um argumento para o comando sudo. Como o comando su, o comando sudo assume por padrão que a conta de usuário root deve ser usada para executar comandos.

Considere o seguinte

O comando sudo também pode ser usado para alternar para outras contas de usuário. Para especificar uma conta de usuário diferente, use a opção -u.

Execute o comando sl como usuário root colocando sudo na frente dele:

Nota

Lembre-se que a senha é netlab123. O prompt para a senha não aparecerá novamente enquanto o usuário continuar executando comandos sudo com menos de cinco minutos de intervalo.

sysadmin@localhost:~$ sudo sl
[sudo] password for sysadmin:

 
                            (@@) (  ) (@)  ( )  @@    ()    @     O     @
                         (   )
                     (@@@@)
                  (    )

                (@@@)
            ====        ________                ___________
        _D _|  |_______/        \__I_I_____===__|_________|
         |(_)---  |   H\________/ |   |        =|___ ___|      _________________
         /     |  |   H  |  |     |   |         ||_| |_||     _|
        |      |  |   H  |__--------------------| [___] |   =|
        | ________|___H__/__|_____/[][]~\_______|       |   -|
        |/ |   |-----------I_____I [][] []  D   |=======|____|__________________
      __/ =| o |=-~~\  /~~\  /~~\  /~~\ ____Y___________|__|____________________
       |/-=|___|=    ||    ||    ||    |_____/~\___/          |_D__D__D_|  |_D__
        \_/      \_O=====O=====O=====O/      \_/               \_/   \_/    \_/

Uma vez concluído o comando, observe que o prompt não foi alterado, você ainda está conectado como sysadmin. O comando sudo fornece apenas acesso administrativo para a execução do comando especificado. Esta é uma vantagem, pois reduz o risco de um usuário executar acidentalmente um comando como root. A intenção de executar um comando é clara; o comando é executado como root se prefixado com o comando sudo. Caso contrário, o comando é executado como um usuário regular.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Permissões**

As permissões determinam as maneiras pelas quais diferentes usuários podem interagir com um arquivo ou diretório. Ao listar um arquivo com o comando ls -l, a saída inclui informações de permissão. Para o exemplo, vamos usar um script chamado hello.sh localizado no diretório Documents:

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

sysadmin@localhost:~/Documents$ ls -l hello.sh                                  
-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

Abaixo está uma revisão dos campos relevantes para permissões.
Campo Tipo de Arquivo

-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

O primeiro caractere desta saída indica o tipo de um arquivo. Lembre-se de que, se o primeiro caractere for um -, este é um arquivo regular. Se o caractere fosse um d, seria um diretório.
Campo Permissões

-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

Após o caractere do tipo de arquivo, as permissões são exibidas. As permissões são divididas em três conjuntos de três caracteres:

    Proprietário

    -rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

    O primeiro conjunto é para o usuário que possui o arquivo. Se a sua conta atual for o proprietário do arquivo, o primeiro conjunto das três permissões será aplicado e as outras permissões não terão efeito.

    O usuário que possui o arquivo e a quem essas permissões se aplicam, pode ser determinado pelo campo proprietário do usuário:

    -rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

    Grupo

    -rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

    O segundo conjunto é para o grupo que possui o arquivo. Se a sua conta atual não for o proprietário do arquivo e você for um membro do grupo que possui o arquivo, então as permissões do grupo serão aplicadas e as outras permissões não terão efeito.

    O grupo para este arquivo pode ser determinado pelo campo proprietário do grupo:

    -rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

    Outros

    -rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

    O último conjunto é para todos os outros, qualquer um que os dois primeiros conjuntos de permissões não se aplicam. Se você não for o usuário proprietário do arquivo ou um membro do grupo que possui o arquivo, o terceiro conjunto de permissões se aplica a você.

Tipos de permissão

Existem três permissões diferentes que podem ser colocadas em um arquivo ou diretório: ler, gravar e executar. A maneira pela qual essas permissões se aplicam difere para arquivos e diretórios, conforme mostrado no gráfico abaixo:
Permissão 	Efeitos no arquivo 	Efeitos no diretório
ler (r) 	Permite que o conteúdo do arquivo seja lido ou copiado. 	Sem permissão de execução no diretório, permite uma lista não detalhada de arquivos. Com permissão de execução, ls -l pode fornecer uma lista detalhada.
escrever (w) 	Permite que o conteúdo seja modificado ou substituído. Permite que arquivos sejam adicionados ou removidos de um diretório. 	Para que essa permissão funcione, o diretório também deve ter permissão de execução.
executar (x) 	Permite que um arquivo seja executado como um processo, embora os arquivos de script exijam permissão de leitura, também. 	Permite que um usuário mude para o diretório se os diretórios pai também tiverem permissão de execução.

Considere isto

Compreender quais permissões se aplicam é um conjunto de habilidades importante no Linux. Por exemplo, considere o seguinte conjunto de permissões:

-rw-rwx. 1 sysadmin staff 999 abr 10 2013 /home/sysadmin/test

Nesse cenário, o usuário sysadmin acaba tendo menos acesso a esse arquivo do que os membros do grupo de staff ou todos os outros. O usuário sysadmin só tem as permissões de r--. Não importa se sysadmin é um membro do grupo de staff; uma vez estabelecida a propriedade do usuário, somente as permissões do proprietário do usuário serão aplicadas.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Alterando permissões de arquivo**

O comando chmod é usado para alterar as permissões de um arquivo ou diretório. Somente o usuário root ou o usuário que possui o arquivo é capaz de alterar as permissões de um arquivo.

Considere o seguinte

Por que o comando é chamado chmod em vez de chperm? As permissões costumavam ser referidas como modos de acesso, então o comando chmod realmente significa alterar os mod os de acesso.

Existem duas técnicas para alterar permissões com o comando chmod: simbólico e octal. O método simbólico é bom para alterar um conjunto de permissões de cada vez. O método octal ou numérico requer o conhecimento do valor octal de cada uma das permissões e requer que todos os três conjuntos de permissões (usuário, grupo, outros) sejam especificados a cada vez. Por uma questão de simplicidade, apenas o método simbólico será coberto. Para saber mais sobre o método octal confira NDG Linux Essentials!

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

O Método Simbólico

chmod [<CONJUNTO><AÇAO><PERMISSÕES>]... ARQUIVO

Para usar o método simbólico de chmod indicar primeiro qual conjunto de permissões está sendo alterado:

chmod [<CONJUNTO><AÇAO><PERMISSÕES>]... ARQUIVO

Símbolo 	Significado
u 	Usuário: o usuário que possui o arquivo.
g 	Grupo: o grupo que possui o arquivo.
o 	Outros: qualquer pessoa que não seja o proprietário do usuário ou membro do proprietário do grupo.
a 	Todos: refere-se ao usuário, grupo e outros.

Em seguida, especifique um símbolo de ação:

chmod [<CONJUNTO><AÇAO><PERMISSÕES>]... ARQUIVO

Simbolo 	Significado
+ 	Adicione a permissão, se necessário
= 	Especifique a permissão exata
- 	Remova a permissão, se necessário

Após um símbolo de ação, especifique uma ou mais permissões a serem executadas.

chmod [<CONJUNTO><AÇAO><PERMISSÕES>]... ARQUIVO

Simbolo 	Significado
r 	ler
w 	escrever
x 	executar

Finalmente, um espaço e os nomes de caminho para os arquivos atribuírem essas permissões.

chmod [<CONJUNTO><AÇAO><PERMISSÕES>]... ARQUIVO

O arquivo hello.sh usado nos exemplos na página anterior é um script. Um script é um arquivo que pode ser executado, semelhante a um comando:

sysadmin@localhost:~/Documents$ ls -l hello.sh                                  
-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

No entanto, atualmente, a permissão de execução não está definida para nenhum dos grupos de permissões:

-rw-r--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

Falha ao tentar executar esse script usando a seguinte sintaxe:

sysadmin@localhost:~/Documents$ ./hello.sh                                      
-bash: ./hello.sh: Permission denied

Como o sistema está atualmente conectado como o usuário sysadmin, e sysadmin é o proprietário deste arquivo, dando ao proprietário do usuário a permissão de execução deve permitir que você execute este script. Usando o comando chmod com o caractere u para representar o conjunto de permissões do proprietário do usuário, o caractere + para indicar uma permissão está sendo adicionado e o caractere x para representar a permissão de execução, o comando deve ser executado da seguinte forma:

sysadmin@localhost:~/Documents$ chmod u+x hello.sh

Nenhuma saída indica que o comando foi bem-sucedido. Confirme verificando as permissões usando o comando ls -l:

sysadmin@localhost:~/Documents$ ls -l hello.sh                                  
-rwxr--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

O proprietário do usuário agora tem a permissão de execução listada:

-rwxr--r-- 1 sysadmin sysadmin 647 Dec 20  2017 hello.sh

Finalmente, tente executar o script novamente. Use a sintaxe de comando mostrada abaixo:

./hello.sh

sysadmin@localhost:~/Documents$ ./hello.sh                                      
 ______________                                                                 
( Hello World! )                                                                
 --------------                                                                 
        \                                                                       
         \                                                                      
           <(^)                                                                 
            ( ) 

Considere o seguinte

Observe que para executar o script no exemplo anterior, um ./ combinação de caracteres foi colocada antes do nome do script.

./hello.sh

Isso indica que o “comando” deve ser executado a partir do diretório atual.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Alterando a propriedade do arquivo**

Inicialmente, o proprietário de um arquivo é o usuário que o cria. O comando chown é usado para alterar a propriedade de arquivos e diretórios. Alterar o proprietário do usuário requer acesso administrativo. Um usuário regular não pode usar esse comando para alterar o proprietário do usuário de um arquivo, mesmo para dar a propriedade de um de seus próprios arquivos a outro usuário. No entanto, o comando chown também permite alterar a propriedade do grupo, o que pode ser feito pela root ou o proprietário do arquivo.

Para alterar o proprietário do usuário de um arquivo, a seguinte sintaxe pode ser usada. O primeiro argumento, [PROPRIETÁRIO], especifica qual usuário deve ser o novo proprietário. O segundo argumento, ARQUIVO, especifica qual propriedade do arquivo está mudando.

chown [OPÇÕES] [PROPRIETÁRIO] ARQUIVO

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

Atualmente, todos os arquivos no diretório Documents são de propriedade do usuário sysadmin. Isso pode ser verificado usando o comando ls -l. Lembre-se de que a terceira coluna indica o proprietário do usuário.

sysadmin@localhost:~/Documents$ ls -l                                           
total 144                                                                       
drwx------ 5 sysadmin sysadmin  4096 Dec 20  2017 School                        
drwx------ 2 sysadmin sysadmin  4096 Dec 20  2017 Work                          
-rw-r--r-- 1 sysadmin sysadmin    39 Dec 20  2017 adjectives.txt                
-rw-r--r-- 1 sysadmin sysadmin    90 Dec 20  2017 alpha-first.txt               
-rw-r--r-- 1 sysadmin sysadmin   106 Dec 20  2017 alpha-second.txt              
-rw-r--r-- 1 sysadmin sysadmin   195 Dec 20  2017 alpha-third.txt               
-rw-r--r-- 1 sysadmin sysadmin   390 Dec 20  2017 alpha.txt                     
-rw-r--r-- 1 sysadmin sysadmin    42 Dec 20  2017 animals.txt                   
-rw-r--r-- 1 sysadmin sysadmin    14 Dec 20  2017 food.txt                      
-rwxr--r-- 1 sysadmin sysadmin   647 Dec 20  2017 hello.sh                      
-rw-r--r-- 1 sysadmin sysadmin    67 Dec 20  2017 hidden.txt                    
-rw-r--r-- 1 sysadmin sysadmin    10 Dec 20  2017 letters.txt                   
-rw-r--r-- 1 sysadmin sysadmin    83 Dec 20  2017 linux.txt                     
-rw-r--r-- 1 sysadmin sysadmin 66540 Dec 20  2017 longfile.txt                  
-rw-r--r-- 1 sysadmin sysadmin   235 Dec 20  2017 newhome.txt                   
-rw-r--r-- 1 sysadmin sysadmin    10 Dec 20  2017 numbers.txt                   
-rw-r--r-- 1 sysadmin sysadmin    77 Dec 20  2017 os.csv                        
-rw-r--r-- 1 sysadmin sysadmin    59 Dec 20  2017 people.csv                    
-rw-r--r-- 1 sysadmin sysadmin   110 Dec 20  2017 profile.txt                   
-rw-r--r-- 1 sysadmin sysadmin    51 Dec 20  2017 red.txt   

Para alternar o proprietário do script hello.sh para o usuário root, use root como o primeiro argumento e hello.sh como o segundo argumento. Não se esqueça de usar o comando sudo para obter os privilégios administrativos necessários. Use a senha netlab123 quando solicitado:

sysadmin@localhost:~/Documents$ sudo chown root hello.sh                        
[sudo] password for sysadmin:

Confirme se o proprietário do usuário foi alterado executando o comando ls -l. Use o nome do arquivo como um argumento para limitar a saída:

sysadmin@localhost:~/Documents$ ls -l hello.sh                                  
-rwxr--r-- 1 root sysadmin 647 Dec 20  2017 hello.sh  

O campo proprietário do usuário agora é root indicando que a alteração foi bem-sucedida.

-rwxr--r-- 1 root sysadmin 647 Dec 20  2017 hello.sh

Considere o seguinte

Tente executar o script hello.sh novamente. Ele falha! Por que?

sysadmin@localhost:~/Documents$ ./hello.sh                                      
-bash: ./hello.sh: Permission denied  

Somente o proprietário do usuário tem a permissão de execução e agora o usuário rooté o proprietário do usuário. Este arquivo agora requer acesso administrativo para ser executado. Use o comando sudo para executar o script como o usuário root.

sysadmin@localhost:~/Documents$ sudo ./hello.sh                                 
[sudo] password for sysadmin:                                                   
 ______________                                                                 
( Hello World! )                                                                
 --------------                                                                 
        \                                                                       
         \                                                                      
           <(^)                                                                 
            ( )  
 
-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Exibindo Arquivos**

Existem alguns comandos Linux disponíveis para visualizar o conteúdo dos arquivos. O comando cat, que significa 'concatenate', é frequentemente usado para visualizar rapidamente o conteúdo de pequenos arquivos.

O comando cat exibirá todo o conteúdo do arquivo, por isso é recomendado principalmente para arquivos menores onde a saída é limitada e não requer rolagem. Para visualizar o conteúdo de um arquivo usando o comando cat, basta digitar o comando e usar o nome do arquivo que você deseja visualizar como argumento:

cat [OPÇÕES] [ARQUIVO]

Nossa VM tem alguns pequenos arquivos de texto que você pode visualizar com o comando cat. Um desses arquivos é o arquivo animals.txt:

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

sysadmin@localhost:~/Documents$ cat animals.txt                            
1 retriever                                                             
2 badger                                                                
3 bat                                                                  
4 wolf                                                                  
5 eagle

O comando cat exibe todas as cinco linhas do arquivo acima. Ao visualizar arquivos maiores, o comando cat pode resultar em uma saída muito longa que não pode ser pausada para rolar. Um melhor método de visualização de arquivos de texto longos,é com um comando de pager que possui uma funcionalidade que pode pausar e rolar pela saída do arquivo.

Nota

Exemplos de comandos de pager incluem comandos more ou less. Estes e os comandos adicionais usados para visualizar arquivos no Linux são cobertos pelo NDG Linux Essentials.

Outra maneira de visualizar o conteúdo dos arquivos é usando os comandos head e tail. Esses comandos são usados para exibir um número selecionado de linhas na parte superior ou inferior de um arquivo. Dar uma olhada em algumas linhas de um arquivo às vezes pode ser útil para garantir que o arquivo seja aquele que você deseja usar.

Outro motivo para visualizar apenas a primeira ou última linha, é porque alguns arquivos, como arquivos de log do sistema, são frequentemente atualizados com novas entradas. Semelhante ao comando cat, os comandos head e tail usam o nome do arquivo que você deseja visualizar como argumento para o comando:

head [OPÇÕES] [ARQUIVO]

tail [OPÇÕES] [ARQUIVO]

Para comparar a saída dos comandos head e tail com a do comando cat, use o comando cat para exibir todo o arquivo alpha.txt:

sysadmin@localhost:~/Documents$ cat alpha.txt       
A is for Apple                    
B is for Bear           
C is for Cat                      
D is for Dog                               
E is for Elephant                                      
F is for Flower       
G is for Grapes                     
H is for Happy                                     
I is for Ink 
J is for Juice                                   
K is for Kangaroo
L is for Lol 
M is for Monkey                       
N is for Nickel                             
O is for Oval                  
P is for Pickle       
Q is for Quark                         
R is for Rat                          
S is for Sloth                       
T is for Turnip                        
U is for Up                                     
V is for Velvet                       
W is for Walrus                    
X is for Xenon                        
Y is for Yellow         
Z is for Zebra           
sysadmin@localhost:~/Documents$

No exemplo acima, todas as vinte e seis linhas do arquivo são exibidas.

Para filtrar as linhas de saída e visualização da parte superior do arquivo alpha.txt, use o comando head:

sysadmin@localhost:~/Documents$ head alpha.txt                          
A is for Apple                                                        
B is for Bear                                                         
C is for Cat                                                        
D is for Dog                                                         
E is for Elephant                                                     
F is for Flower                                                       
G is for Grapes                                                        
H is for Happy                                                        
I is for Ink                                                          
J is for Juice

Em seguida, para exibir linhas na parte inferior do arquivo alpha.txt, use o comando tail:

sysadmin@localhost:~/Documents$ tail alpha.txt                          
Q is for Quark                                                         
R is for Rat                                                           
S is for Sloth                                                        
T is for Turnip                                                        
U is for Up                                                            
V is for Velvet                                                      
W is for Walrus                                                        
X is for Xenon                                                        
Y is for Yellow                                                        
Z is for Zebra

Ao examinar a saída dos comandos head e tail acima, você pode ver que o comportamento padrão dos comandos head e tail neste shell é exibir dez linhas.

A opção -n com os comandos head e tail pode ser usada para especificar a quantidade de linhas a serem exibidas. Para usar a opção -n, especifique a quantidade de linhas do arquivo que deseja exibir após a opção e use o nome do arquivo como argumento:

head -n número_de_linhas nome_do_arquivo

Por exemplo, para alterar a saída do comando head para exibir as primeiras cinco linhas do arquivo alpha.txt:

sysadmin@localhost:~/Documents$ head -n 5 alpha.txt                    
A is for Apple                                                         
B is for Bear                                                          
C is for Cat                                                           
D is for Dog                                                           
E is for Elephant

Exibir as últimas cinco linhas do arquivo alpha.txt:

sysadmin@localhost:~/Documents$ tail -n 5 alpha.txt 
V is for Velvet                                                        
W is for Walrus                                                         
X is for Xenon                                                          
Y is for Yellow                                                         
Z is for Zebra            
sysadmin@localhost:~/Documents$

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Copiando Arquivos**

Criar cópias de arquivos pode ser útil por vários motivos:

    Se uma cópia de um arquivo for criada antes que as alterações sejam feitas, é possível voltar ao original.

    Uma cópia de um arquivo pode ser usada para transferir um arquivo para dispositivos de mídia removíveis.

    Uma cópia de um documento existente pode ser usada como modelo para um novo documento.

cp [OPÇÕES] FONTE DESTINO

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

O comando cp é usado para copiar arquivos. Semelhante ao comando mv, ele requer pelo menos dois argumentos: uma origem e um destino. Por exemplo, para copiar o arquivo /etc/passwd para o diretório atual, use o seguinte comando:

sysadmin@localhost:~/Documents$ cp /etc/passwd .

Nota

O segundo argumento é caratere (.). Lembre-se da seção Alterando Diretórios que é um atalho que representa o diretório atual.

O resultado da execução do comando anterior criaria uma cópia do conteúdo do arquivo /etc/passwd no diretório Documents, uma vez que esse é o nosso diretório atual. Isso pode ser confirmado usando o comando ls:

sysadmin@localhost:~/Documents$ ls
School            alpha-third.txt  hidden.txt    numbers.txt  red.txt           
Work              alpha.txt        letters.txt   os.csv                         
adjectives.txt    animals.txt      linux.txt     passwd                         
alpha-first.txt   food.txt         longfile.txt  people.csv                     
alpha-second.txt  hello.sh         newhome.txt   profile.txt

Considere o seguinte

As permissões podem ter um impacto nos comandos de gerenciamento de arquivos, como o comando cp. Para copiar um arquivo, é necessário ter permissão de execução para acessar o diretório onde o arquivo está localizado e a permissão de leitura para o arquivo que está sendo copiado.

Também é necessário ter permissão de gravação e execução no diretório para o qual o arquivo está sendo copiado. Normalmente, há dois lugares onde você sempre deve ter permissão de gravação e execução no diretório: seu diretório home e o diretório /tmp.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Copiando Arquivos**

O comando dd é um utilitário para copiar arquivos ou partições inteiras no nível de bits.

dd [OPÇÕES] OPERANDO

Este comando tem vários recursos úteis, inclusive:

    Pode ser usado para clonar ou excluir (limpar) discos ou partições inteiros.
    Pode ser usado para copiar dados brutos para dispositivos removíveis, como unidades USB e CDROMs.
    Pode fazer backup e restaurar o MBR (Master Boot Record).
    Pode ser usado para criar um arquivo de tamanho específico preenchido com zeros binários, que pode ser usado como um arquivo de swap (memória virtual).

Vamos examinar o seguinte exemplo. O comando dd cria um arquivo chamado /tmp/swapex com 50 blocos de zeros que têm um megabyte de tamanho:

Acompanhe

Use o seguinte comando cd para retornar ao diretório home:

sysadmin@localhost:~/Documents$ cd ~

sysadmin@localhost:~$ dd if=/dev/zero of=/tmp/swapex bs=1M count=50 
50+0 records in
50+0 records out
52428800 bytes (52 MB) copied, 0.825745 s, 635 MB/s

O comando dd usa argumentos especiais para especificar como ele funcionará. A seguir ilustra alguns dos argumentos mais comumente usados:
Argumento 	Descrição
if 	

Arquivo de entrada: O arquivo de entrada a ser lido.

dd if=/dev/zero of=/tmp/swapex bs=1M count=50

O exemplo lê do arquivo /dev/zero, um arquivo especial contendo um número ilimitado de zeros.
of 	

Arquivo de saída: O arquivo de saída a ser gravado.

dd if=/dev/zero of=/tmp/swapex bs=1M count=50

bs 	

Tamanho do bloco: O tamanho do bloco a ser usado. Por padrão, o valor é considerado em bytes. Use os seguintes sufixos para especificar outras unidades: K, M, G e T para kilobytes, megabytes, gigabytes e terabytes respectivamente.

dd if=/dev/zero of=/tmp/swapex bs=1M count=50

O exemplo usa um tamanho de bloco de um megabyte.
count 	

Contagem: O número de blocos a serem lidos a partir do arquivo de entrada.

dd if=/dev/zero of=/tmp/swapex bs=1M count=50

O comando de exemplo lê 50 blocos.

Considere o seguinte

Nenhum tamanho de bloco ou contagem precisa ser especificado ao copiar em dispositivos inteiros. Por exemplo, para clonar de um disco rígido (/dev/sda) para outro (/dev/sdb) execute o seguinte comando:

dd if=/dev/sda of=/dev/sdb

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Mover arquivos**

O comando mv é usado para mover um arquivo de um local no sistema de arquivos para outro.

mv FONTE DESTINO

O comando mv requer pelo menos dois argumentos. O primeiro argumento é a fonte, um caminho para o arquivo a ser movido. O segundo argumento é o destino, um caminho para onde o arquivo será movido. Os arquivos a serem movidos às vezes são chamados de origem, e o local onde os arquivos devem ser colocados é chamado de destino.

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

Para mover o arquivo people.csv para o diretório Work, use o nome do arquivo como origem e o nome do diretório como destino:

sysadmin@localhost:~/Documents$ mv people.csv Work

Se um arquivo for movido de um diretório para outro sem especificar um novo nome para o arquivo, ele manterá seu nome original. A movimentação acima pode ser confirmada usando o comando ls no diretório Work:

sysadmin@localhost:~/Documents$ ls Work                                         
people.csv

O comando mv é capaz de mover vários arquivos, desde que o argumento final fornecido ao comando seja o destino. Por exemplo, para mover três arquivos para o diretório School:

sysadmin@localhost:~/Documents$ mv numbers.txt letters.txt alpha.txt School        
sysadmin@localhost:~/Documents$ ls School                                       
Art  Engineering  Math  alpha.txt  letters.txt  numbers.txt  

Mover um arquivo dentro do mesmo diretório é uma maneira eficaz de renomeá-lo. Por exemplo, no exemplo a seguir, o arquivo animals.txt recebe um novo nome de zoo.txt:

mv animals.txt zoo.txt

sysadmin@localhost:~/Documents$ ls                                              
School           alpha-second.txt  hello.sh      newhome.txt  red.txt           
Work             alpha-third.txt   hidden.txt    os.csv                         
adjectives.txt   animals.txt       linux.txt     passwd                         
alpha-first.txt  food.txt          longfile.txt  profile.txt 
sysadmin@localhost:~/Documents$ mv animals.txt zoo.txt                          
sysadmin@localhost:~/Documents$ ls                                              
School           alpha-second.txt  hidden.txt    os.csv       zoo.txt           
Work             alpha-third.txt   linux.txt     passwd                         
adjectives.txt   food.txt          longfile.txt  profile.txt                    
alpha-first.txt  hello.sh          newhome.txt   red.txt   

Considere isto

As permissões podem ter um impacto nos comandos de gerenciamento de arquivos, como o comando mv. Mover um arquivo requer permissões de gravação e execução tanto nos diretórios de origem quanto nos de destino.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Removendo arquivos**

O comando rm é usado para excluir arquivos e diretórios. É importante ter em mente que arquivos e diretórios excluídos não entram em uma “lixeira” como acontece com sistemas operacionais voltados para a área de trabalho. Quando um arquivo é excluído com o comando rm, ele quase sempre desaparece permanentemente.

rm [OPÇÕES] ARQUIVO

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

Sem opções, o comando rm é normalmente usado para remover arquivos regulares:

sysadmin@localhost:~/Documents$ rm linux.txt
sysadmin@localhost:~/Documents$ ls linux.txt
ls: cannot access linux.txt: No such file or directory

O comando rm ignorará os diretórios que é solicitado a remover; para excluir um diretório, use uma opção recursiva, seja as opções -r ou -R . Basta ter cuidado, uma vez que estas opções são “recursivas”, isto irá eliminar todos os arquivose todos os subdiretórios:

sysadmin@localhost:~/Documents$ rm Work
rm: cannot remove 'Work': Is a directory
sysadmin@localhost:~/Documents$ rm -r Work
sysadmin@localhost:~/Documents$ ls Work                                         
ls: cannot access Work: No such file or directory

Aviso

O comando rm remove arquivos permanentemente. Para repetir os exemplos acima, redefina o terminal usando o botão de reinicialização.

Considere isto

As permissões podem ter um impacto nos comandos de gerenciamento de arquivos, como o comando rm.

Para excluir um arquivo dentro de um diretório, um usuário deve ter permissão de gravação e execução em um diretório. Normalmente, os usuários regulares só têm esse tipo de permissão em seu diretório (home) pessoal e seus subdiretórios.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Filtragem de Entrada**

O comando grep é um filtro de texto que irá procurar linhas de entrada e retorno que contenham uma correspondência para um determinado padrão.

grep [OPÇÕES] PADRÃO [ARQUIVO]

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

Se o exemplo abaixo falhar, repita o exemplo da Seção 11:

sysadmin@localhost:~/Documents$ cp /etc/passwd .

Por exemplo, o arquivo passwd que copiamos anteriormente para o diretório Documents contém os detalhes de contas especiais do sistema e contas de usuário no sistema. Este arquivo pode ser muito grande, no entanto, o comando grep pode ser usado filtrar informações sobre um usuário específico, como o usuário sysadmin. Use sysadmin como argumento de padrão e passwd como argumento de arquivo:

sysadmin@localhost:~/Documents$ grep sysadmin passwd                               
sysadmin:x:1001:1001:System Administrator,,,,:/home/sysadmin:/bin/bash 

O comando acima retornou a linha do passwd que contém o sysadmin padrão.

Nota

Esta linha é a entrada /etc/passwd pertencente ao usuário sysadmin e fornece informações que estão além do escopo deste curso. Para saber mais sobre este arquivo, confira o NDG Linux Essentials.

O exemplo acima usa um termo de pesquisa simples como padrão, no entanto grep é capaz de interpretar padrões de pesquisa muito mais complexos.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Expressões Regulares**

As expressões regulares têm duas formas comuns: básica e estendida. A maioria dos comandos que usam expressões regulares pode interpretar expressões regulares básicas. No entanto, expressões regulares estendidas não estão disponíveis para todos os comandos e uma opção de comando é normalmente necessária para que eles funcionem corretamente.

A tabela a seguir resume os caracteres básicos de expressão regular:
Caracteres Regex básicos 	Significado
. 	Qualquer caractere único
[ ] 	Qualquer caractere especificado
[^ ] 	Não é o caractere especificado
* 	Zero ou mais caracteres anteriores
^ 	Se o primeiro caractere do padrão, o padrão deve estar no início da linha para corresponder, caso contrário, apenas um literal ^
$ 	Se o último caractere do padrão, o padrão deve estar no final da linha para corresponder, caso contrário, apenas um literal $

A tabela a seguir resume as expressões regulares estendidas, que devem ser usadas com o comando egrep ou a opção -E com o comando grep:
Caracteres Regex extendidos 	Significado
+ 	Um ou mais do padrão anterior
? 	O padrão anterior é opcional
{ } 	Especifique correspondências mínimas, máximas ou exatas do padrão anterior
| 	Alternação - um "ou" lógico
( ) 	Usado para criar grupos

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Padrões básicos**

Expressões regulares são padrões que apenas certos comandos são capazes de interpretar. Expressões regulares podem ser expandidas para corresponder a determinadas sequências de caracteres no texto. Os exemplos exibidos nesta página farão uso de expressões regulares para demonstrar seu poder quando usado com o comando grep. Além disso, esses exemplos fornecem uma demonstração muito visual de como as expressões regulares funcionam, o texto correspondente será exibido em uma cor vermelha.

Acompanhe

Use o seguinte comando cd para alterar para o diretório Documents.

sysadmin@localhost:~$ cd ~/Documents

A mais simples de todas as expressões regulares usam apenas caracteres literais, como o exemplo da página anterior:

sysadmin@localhost:~/Documents$ grep sysadmin passwd                               
sysadmin:x:1001:1001:System Administrator,,,,:/home/sysadmin:/bin/bash

Caracteres Ancora

Caracteres âncora são uma das formas como expressões regulares podem ser usadas para restringir os resultados da pesquisa. Por exemplo, a root padrão aparece muitas vezes no arquivo /etc/passwd:

sysadmin@localhost:~/Documents$ grep 'root' passwd
root:x:0:0:root:/root:/bin/bash                                                 
operator:x:1000:37::/root:

Para evitar que o shell os intérprete erroneamente como caracteres especiais, esses padrões devem ser protegidos por aspas fortes, o que significa simplesmente colocá-los entre aspas simples.

O primeiro caractere âncora ^ é usado para garantir que um padrão apareça no início da linha. Por exemplo, para encontrar todas as linhas em /etc/passwd que começam com root use o padrão ^root. Observe que ^ deve ser o primeiro caractere no padrão para ser efetivo.

sysadmin@localhost:~/Documents$ grep '^root' /etc/passwd
root:x:0:0:root:/root:/bin/bash

Para o próximo exemplo, primeiro examine o arquivo alpha-first.txt. O comando cat pode ser usado para imprimir o conteúdo de um arquivo:

sysadmin@localhost:~/Documents$ cat alpha-first.txt                             
A is for Animal                                                                 
B is for Bear                                                                   
C is for Cat                                                                    
D is for Dog                                                                    
E is for Elephant                                                               
F is for Flower

O segundo caractere âncora $ pode ser usado para garantir que um padrão apareça no final da linha, reduzindo assim efetivamente os resultados da pesquisa. Para encontrar as linhas que terminam com um r no arquivo alpha-first.txt, use o padrão r$:

sysadmin@localhost:~/Documents$ grep 'r$' alpha-first.txt
B is for Bear
F is for Flower

Novamente, a posição deste caractere é importante, o $ deve ser o último caractere no padrão para ser eficaz como uma âncora.
Combine um único caractere com .

Os exemplos a seguir usarão o arquivo red.txt:

sysadmin@localhost:~/Documents$ cat red.txt
red
reef
rot
reeed
rd
rod
roof
reed
root
reel
read

Uma das expressões mais úteis é o caractere de ponto .. Ele irá corresponder a qualquer caractere, exceto para o novo caractere de linha. O padrão r..f encontraria qualquer linha que contenhaa letra r seguida por exatamente dois caracteres (que pode ser qualquer caractere exceto uma nova linha) e, em seguida, a letra f:

sysadmin@localhost:~/Documents$ grep 'r..f' red.txt
reef
roof

O mesmo conceito pode ser repetido usando outras combinações. O seguinte encontrará quatro palavras de letra que começam com r e com d:

sysadmin@localhost:~/Documents$ grep 'r..d' red.txt
reed
read

Este caractere pode ser usado qualquer número de vezes. Para localizar todas as palavras que tenham pelo menos quatro caracteres, o seguinte padrão pode ser usado:

sysadmin@localhost:~/Documents$ grep '....' red.txt                             
reef
reeed
roof                                                                            
reed
root
reel
read

A linha não precisa ser uma correspondência exata, ela simplesmente deve conter o padrão, como visto aqui quando r..t é pesquisado no arquivo /etc/passwd:

sysadmin@localhost:~/Documents$ grep 'r..t' /etc/passwd
root:x:0:0:root:/root:/bin/bash
operator:x:1000:37::/root:  

Corresponder um único caractere com []

Os colchetes [] correspondem a um único caractere da lista ou intervalo de caracteres possíveis contidos entre parênteses.

Por exemplo, dado o arquivo profile.txt:

sysadmin@localhost:~/Documents$ cat profile.txt
Hello my name is Joe.
I am 37 years old.
3121991
My favorite food is avocados.
I have 2 dogs.
123456789101112

Para encontrar todas as linhas no profile.txt que têm um número neles, use o padrão [0123456789] ou [0-9]:

sysadmin@localhost:~/Documents$ grep '[0-9]' profile.txt
I am 37 years old.
3121991
I have 2 dogs.
123456789101112

Por outro lado, para encontrar todas as linhas que contêm caracteres não numéricos, insira um ^ como o primeiro caractere dentro dos colchetes. Este caractere nega os caracteres listados:

sysadmin@localhost:~/Documents$ grep '[^0-9]' profile.txt
Hello my name is Joe.
I am 37 years old.
My favorite food is avocados.
I have 2 dogs.

Nota

Não confunda [^0-9] para corresponder às linhas que não contêm números. Na verdade, corresponde a linhas que contêm não-números. Olhe para o arquivo original para ver a diferença. A terceira e a sexta linhas contêm apenas números, elas não contêm os não-números então essas linhas não correspondem.

Quando outros caracteres de expressão regular são colocados dentro de colchetes, eles são tratados como caracteres literais. Por exemplo, o . normalmente corresponde a qualquer caractere, mas colocado dentro dos colchetes, então ele irá apenas corresponder a si mesmo. No próximo exemplo, somente linhas que contêm o . são correspondidos.

sysadmin@localhost:~/Documents$ grep '[.]' profile.txt
Hello my name is Joe.
I am 37 years old.
My favorite food is avocados.
I have 2 dogs.

Combine um personagem ou padrões repetidos com *

O caractere de expressão regular * é usado para corresponder zero ou mais ocorrências de um caractere ou padrão que o precede. Por exemplo e* corresponderia a zero ou mais ocorrências da letra e:

sysadmin@localhost:~/Documents$ cat red.txt
red
reef
rot
reeed
rd
rod
roof
reed
root
reel
read
sysadmin@localhost:~/Documents$ grep 're*d' red.txt
red
reeed
rd
reed

Também é possível combinar zero ou mais ocorrências de uma lista de caracteres utilizando os colchetes. O padrão [oe]* usado no exemplo a seguir corresponderá a zero ou mais ocorrências do caractere o ou do caractere e:

sysadmin@localhost:~/Documents$ grep 'r[oe]*d' red.txt
red
reeed
rd
rod
reed

Quando usado com apenas um outro caractere, * não é muito útil. Qualquer um dos padrões a seguir corresponderia a cada string ou linha no arquivo: .* e* b* z*.

sysadmin@localhost:~/Documents$ grep 'z*' red.txt
red
reef
rot
reeed
rd
rod
roof
reed
root
reel
read

sysadmin@localhost:~/Documents$ grep 'e*' red.txt
red
reef
rot
reeed
rd
rod
roof
reed
root
reel
read

Isso ocorre porque * pode corresponder a zero ocorrências de um padrão. Para tornar o* útil, é necessário criar um padrão que inclua mais do que apenas um caractere precedente a*. Por exemplo, os resultados acima podem ser refinados adicionando outro e para fazer com que o padrão ee* corresponda efetivamente a cada linha que contém pelo menos um e.

sysadmin@localhost:~/Documents$ grep 'ee*' red.txt
red
reef
reeed
reed
reel
read

Entrada padrão

Se um nome de arquivo não for fornecido, o comando grep será lido a partir de entrada padrão, que normalmente vem do teclado com entrada fornecida pelo usuário que executa o comando. Isso fornece uma experiência interativa com grep onde o usuário digita na entrada e os filtros do grep à medida que vai. Sinta-se livre para experimentá-lo, basta pressionar Ctrl-D quando estiver pronto para retornar ao prompt.

Acompanhe

Use o seguinte comando cd para retornar ao diretório home:

sysadmin@localhost:~/Documents$ cd ~

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Desligando**

O comando shutdown faz com que o sistema seja desligado de forma segura. Todos os usuários conectados são notificados de que o sistema está sendo desativado e, nos últimos cinco minutos que antecederam o desligamento, novos logins são evitados.

shutdown [OPÇÕES] TEMPO [MENSAGEM]

Acompanhe

O comando shutdown requer acesso administrativo, mude para a conta root desta seção usando o seguinte comando. Use netlab123 como senha.

sysadmin@localhost:~$ su -                                                   
Password:                                                                       
root@localhost:~#

Nossas máquinas virtuais não vão realmente desligar! Sinta-se à vontade para usar o comando, mas lembre-se de que ele apenas reverterá ao prompt após a contagem regressiva, em vez de derrubar o sistema. Pode ser necessário pressionar Enter para retornar o prompt de comando.

root@localhost:~# shutdown now                                         
                                                                                
Broadcast message from sysadmin@localhost                                       
        (/dev/pts/0) at 2:05 ...                                              
                                                                                
The system is going down for maintenance NOW! 

Ao contrário de outros comandos usados para desligar o sistema, o comando shutdown requer um argumento de tempo especificando quando o desligamento deve começar. Os formatos deste argumento de tempo podem ser a palavra now (agora), uma hora do dia no formato hh:mm ou o número de minutos para atrasar no formato +minutos.

Considere o seguinte

O relógio do nosso sistema pode ser definido para um fuso horário diferente daquele em que você está localizado. Para verificar a hora no terminal, use o comando date. Em nossas máquinas, o formato padrão da saída do comando date é o seguinte:

dia_da_semana mês dia hora:minuto:segundo ano UTC

As letras UTC presentes na saída indica que o tempo está sendo exibido como Tempo Coordenado Universal.

root@localhost:~# date                                                      
Sat Oct  3 22:15:58 UTC 2020 
root@localhost:~# shutdown 01:51                                                
                                                                                
Broadcast message from sysadmin@localhost                                       
        (/dev/pts/0) at 1:50 ...                                              
                                                                                
The system is going down for maintenance in 1 minute!

Broadcast message from sysadmin@localhost                                       
        (/dev/pts/0) at 1:51 ...                                              
                                                                                
The system is going down for maintenance NOW! 

O comando shutdown também tem um argumento de mensagem opcional, indicando uma mensagem que aparecerá nos terminais de todos os usuários. Por exemplo:

root@localhost:~# shutdown +1 "Goodbye World!"                                  
                                                                                
Broadcast message from sysadmin@localhost                                       
        (/dev/pts/0) at 3:07 ...                                              
                                                                                
The system is going down for maintenance in 1 minute!                           
Goodbye World!                                                                  
shutdown: Unable to shutdown system                                             
root@localhost:~#                                                             
Broadcast message from sysadmin@localhost                                       
        (/dev/pts/0) at 3:08 ...                                              
                                                                                
The system is going down for maintenance NOW!                                   
Goodbye World!                                

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Configuração de rede**

O comando ifconfig significa “configuração de interface” e é usado para exibir informações sobre a configuração de rede.

ifconfig [OPÇÕES]

Nota

O comando iwconfig é semelhante ao comando ifconfig, mas é dedicado a interfaces de rede sem fio.

Nem todas as configurações de rede são importantes para este módulo, mas é importante observar no exemplo a seguir que o endereço IPv4 do dispositivo de rede principal eth0 é 192.168.1.2 e que o dispositivo está atualmente ativo (UP):

root@localhost:~# ifconfig                                     
eth0      Link encap:Ethernet  HWaddr 02:42:c0:a8:01:02                         
          inet addr:192.168.1.2  Bcast:192.168.1.255  Mask:255.255.255.0        
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1                    
          RX packets:59 errors:0 dropped:0 overruns:0 frame:0                   
          TX packets:86 errors:0 dropped:0 overruns:0 carrier:0                 
          collisions:0 txqueuelen:1000                                          
          RX bytes:4346 (4.3 KB)  TX bytes:5602 (5.6 KB)                        
                                                                                
lo        Link encap:Local Loopback                                             
          inet addr:127.0.0.1  Mask:255.0.0.0                                   
          UP LOOPBACK RUNNING  MTU:65536  Metric:1                              
          RX packets:2 errors:0 dropped:0 overruns:0 frame:0                    
          TX packets:2 errors:0 dropped:0 overruns:0 carrier:0                  
          collisions:0 txqueuelen:1000                                          
          RX bytes:100 (100.0 B)  TX bytes:100 (100.0 B)           

Considere o seguinte

O dispositivo lo é referido como o dispositivo de loopback. É um dispositivo de rede especial usado pelo sistema ao enviar dados baseados em rede para si mesmo.

O comando ifconfig também pode ser usado para modificar temporariamente as configurações de rede. Normalmente, essas alterações devem ser permanentes, portanto, usar o comando ifconfig para fazer essas alterações é bastante raro.

O comando ping é usado para verificar a conectividade entre dois computadores. Ele faz isso enviando pacotes para outra máquina em uma rede. Se o remetente receber uma resposta, deverá ser possível conectar-se a essa máquina.

As informações são enviadas usando 'pacotes'; a unidade encapsulada de dados enviados através de uma rede. Para que os pacotes encontrem o outro computador, eles precisarão de um endereço. O comando ping usa endereços IP para identificar um computador na rede ao qual ele deseja se conectar.

Por padrão, o comando ping continuará enviando pacotes até que o comando break (CTL-C) seja inserido no console. Para limitar quantos pings são enviados, use a opção -c seguida do número de pings a serem enviados. O exemplo abaixo mostra ping sendo limitado a 4 iterações com -c 4.

Se o comando ping for bem-sucedido, você verá uma saída como a seguinte:

root@localhost:~# ping -c 4 192.168.1.2                                       
PING 192.168.1.2 (192.168.1.2) 56(84) bytes of data.                          
64 bytes from 192.168.1.2: icmp_req=1 ttl=64 time=0.051 ms                    
64 bytes from 192.168.1.2: icmp_req=2 ttl=64 time=0.064 ms                    
64 bytes from 192.168.1.2: icmp_req=3 ttl=64 time=0.050 ms                    
64 bytes from 192.168.1.2: icmp_req=4 ttl=64 time=0.043 ms                    
                                                                              
--- 192.168.1.2 ping statistics ---                                           
4 packets transmitted, 4 received, 0% packet loss, time 2999ms                
rtt min/avg/max/mdev = 0.043/0.052/0.064/0.007 ms                             
root@localhost:~#

Se o comando ping falhar, você receberá uma mensagem informando: Destination Host Unreachable (Host de destino inacessível):

root@localhost:~# ping -c 4 192.168.1.3                                       
PING 192.168.1.3 (192.168.1.3) 56(84) bytes of data.                            
From 192.168.1.2 icmp_seq=1 Destination Host Unreachable                        
From 192.168.1.2 icmp_seq=2 Destination Host Unreachable                        
From 192.168.1.2 icmp_seq=3 Destination Host Unreachable                        
From 192.168.1.2 icmp_seq=4 Destination Host Unreachable                        
                                                                                
--- 192.168.1.3 ping statistics ---                                             
4 packets transmitted, 0 received, +4 errors, 100% packet loss, time 3065ms     
pipe 4  
root@localhost:~#

O comando ping pode falhar mesmo que a máquina remota esteja se conectando. Isso ocorre porque alguns administradores configuram suas máquinas, ou mesmo redes inteiras, para não responder a solicitações de ping como medida de segurança. O comando ping também funciona com um nome de host ou nome de domínio, como yahoo.com. Usando este primeiro, se o comando ping for bem sucedido, haverá uma resolução apropriada do nome e o endereço IP também estará funcionando corretamente.
Acompanhe

Saia da conta root usando o comando exit:

root@localhost:~# exit                                                        
logout

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Exibindo Processos**

A execução de um comando resulta em algo chamado processo. No sistema operacional Linux, os processos são executados com os privilégios do usuário que executa o comando. Isso permite que os processos sejam limitados a determinados recursos com base na identidade do usuário.

Embora existam exceções, geralmente o sistema operacional diferenciará os usuários com base no fato de serem eles, ou não, o administrador. Normalmente, os usuários regulares, como o usuário sysadmin, não podem controlar os processos de outro usuário. Os usuários que têm privilégios administrativos, como a conta root, podem controlar qualquer processo do usuário, inclusive a interrupção de qualquer processo de usuário.

O comando ps pode ser usado para listar processos.

ps [OPÇÕES]

sysadmin@localhost:~$ ps
  PID TTY          TIME CMD
   80 pts/0        00:00:00 bash
   94 pts/0        00:00:00 ps

O comando ps exibirá os processos que estão sendo executados no terminal atual por padrão. No exemplo acima, a linha inferior é o processo criado pela execução do comando ps. A saída inclui as seguintes colunas de informações:

    PID: O identificador do processo, que é exclusivo para o processo. Esta informação é útil para controlar o processo pelo seu número de identificação.
    TTY: O nome do terminal em que o processo está sendo executado. Esta informação é útil para distinguir entre diferentes processos que têm o mesmo nome.
    TIME: A quantidade total de tempo do processador usado pelo processo. Normalmente, essas informações não são usadas por usuários comuns.
    CMD: O comando que iniciou o processo.

Em vez de visualizar apenas os processos em execução no terminal atual, os usuários podem querer visualizar todos os processos em execução no sistema. A opção -e exibirá todos os processos:

sysadmin@localhost:~$ ps -e
  PID TTY          TIME CMD                                                     
    1 pts/0        00:00:00 init                                                    
   33 ?            00:00:00 rsyslogd                                                
   37 ?            00:00:00 cron                                                    
   39 ?            00:00:00 sshd                                                    
   56 ?            00:00:00 named                                                   
   69 pts/0        00:00:00 login                                                   
   79 pts/0        00:00:00 bash                                                    
   94 pts/0        00:00:00 ps 

Normalmente, a opção -f também é usada, pois fornece mais detalhes na saída do comando, incluindo opções e argumentos. Procure o comando ps na última linha, a coluna CMD agora inclui as opções usadas:

sysadmin@localhost:~$ ps -ef
UID        PID  PPID  C STIME TTY          TIME CMD                             
root         1     0  0 19:16 pts/0        00:00:00 /sbin??? /init                  
syslog      33     1  0 19:16 ?            00:00:00 /usr/sbin/rsyslogd              
root        37     1  0 19:16 ?            00:00:00 /usr/sbin/cron                  
root        39     1  0 19:16 ?            00:00:00 /usr/sbin/sshd                  
bind        56     1  0 19:16 ?            00:00:00 /usr/sbin/named -u bind         
root        69     1  0 19:16 pts/0        00:00:00 /bin/login -f                   
sysadmin    79    69  0 19:16 pts/0        00:00:00 -bash                           
sysadmin    95    79  0 19:43 pts/0        00:00:00 ps -ef  

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Gerenciamento de pacotes**

O gerenciamento de pacotes é um sistema pelo qual o software pode ser instalado, atualizado, consultado ou removido de um sistema de arquivos. No Linux, existem muitos sistemas diferentes de gerenciamento de pacotes de software diferentes, mas os dois mais populares são os do Debian e da Red Hat. As máquinas virtuais para este curso usam o Ubuntu, um derivado do Debian.

No nível mais baixo do sistema de gerenciamento de pacotes Debian está o comando dpkg. Este comando pode ser complicado para usuários iniciantes do Linux, então a Advanced Package Tool, apt-get, um programa front-end para a ferramenta dpkg, torna o gerenciamento de pacotes ainda mais fácil.

Nota

Um programa front-end é um programa com o qual os usuários podem ver e interagir.

Acompanhe

Muitos dos comandos de gerenciamento de pacotes exigem acesso administrativo, portanto, eles serão prefaciados com o comando sudo. Use netlab123 como senha quando solicitado.
Instalando Pacotes

Os arquivos de pacote são normalmente instalados baixando-os diretamente de repositórios localizados em servidores de Internet. Os repositórios Debian contêm mais de 65.000 pacotes diferentes de software. Antes de instalar um pacote, é uma boa prática usar a atualização da lista de pacotes disponíveis usando o comando apt-get update.
Os comandos a seguir podem levar alguns minutos para serem executados.

sudo apt-get update

sysadmin@localhost:~$ sudo apt-get update                                       
[sudo] password for sysadmin:                                                   
Ign file: amd64/ InRelease                                                      
Ign file: amd64/ Release.gpg                                                    
Ign file: amd64/ Release                                                        
Reading package lists... Done

Para procurar palavras-chave dentro desses pacotes, você pode usar o comando apt-cache search.

apt-cache search [palavra chave]

A palavra-chave usada deve corresponder a parte do nome ou descrição do pacote que deve ser localizado. Várias palavras-chave podem ser usadas para esclarecer ainda mais a pesquisa; por exemplo, o termo de pesquisa servidor web forneceria melhores resultados do que web ou servidor.

Para encontrar pacotes associados à palavra-chave cow:

sysadmin@localhost:~$ apt-cache search cow                                      
cowsay - configurable talking cow

Depois de encontrar o pacote que deseja instalar, você pode instalá-lo com o comando apt-get install:

sudo apt-get install [pacote]

sysadmin@localhost:~$ sudo apt-get install cowsay                               
[sudo] password for sysadmin:                                                   
Reading package lists... Done                                                   
Building dependency tree                                                        
Reading state information... Done                                               
Suggested packages:                                                             
  filters                                                                       
The following NEW packages will be installed:                                   
  cowsay                                                                        
0 upgraded, 1 newly installed, 0 to remove and 0 not upgraded.                  
Need to get 0 B/18.5 kB of archives.                                            
After this operation, 90.1 kB of additional disk space will be used.            
                                                                                
Selecting previously unselected package cowsay.                                 
(Reading database ... 24313 files and directories currently installed.)         
Preparing to unpack .../cowsay_3.03+dfsg1-6_all.deb ...                         
Unpacking cowsay (3.03+dfsg1-6) ...                                             
Processing triggers for man-db (2.6.7.1-1ubuntu1) ...                           
Setting up cowsay (3.03+dfsg1-6) ...

Considere o seguinte

O comando cowsay é uma vaca falante configurável! Use uma palavra ou frase como argumento:

sysadmin@localhost:~$ cowsay 'NDG Linux Unhatched'                              
 _____________________                                                          
< NDG Linux Unhatched >                                                         
 ---------------------                                                          
        \   ^__^                                                                
         \  (oo)\_______                                                        
            (__)\       )\/\                                                    
                ||----w |                                                       
                ||     ||    
 

Recomendamos incluir o argumento entre aspas simples para evitar que o shell interprete caracteres especiais.
Atualizando Pacotes

O comando apt-get install também pode atualizar um pacote, se esse pacote estiver instalado e uma versão mais recente estiver disponível. Se o pacote ainda não estiver no sistema, ele será instalado; se estiver no sistema, ele será atualizado.

A atualização de todos os pacotes do sistema deve ser feita em duas etapas. Primeiro, atualize o cache de todos os pacotes disponíveis com o apt-get update. Em segundo lugar, execute o comando apt-get upgrade e todos os pacotes e dependências serão atualizados.

apt-get update

apt-get upgrade

sysadmin@localhost:~$ sudo apt-get update                                       
[sudo] password for sysadmin:                                                   
Ign file: amd64/ InRelease                                                      
Ign file: amd64/ Release.gpg                                                    
Ign file: amd64/ Release                                                        
Reading package lists... Done                                                   
sysadmin@localhost:~$ sudo apt-get upgrade                                      
Reading package lists... Done                                                   
Building dependency tree                                                        
Reading state information... Done                                               
Calculating upgrade... Done                                                     
0 upgraded, 0 newly installed, 0 to remove and 0 not upgraded. 

Removendo Pacotes

O comando apt-get é capaz de remover ou limpar um pacote. A diferença entre os dois é que a limpeza apaga todos os arquivos de pacote, enquanto a remoção exclui todos os arquivos de configuração do pacote, exceto os arquivos de configuração.

Um administrador pode executar o comando apt-get remove para remover um pacote ou o comando apt-get purge para limpar um pacote completamente do sistema.

apt-get remove [pacote]

apt-get purge [pacote]

Por exemplo, para limpar cowsay completamente, execute o seguinte comando. Digite Y quando solicitado:

sysadmin@localhost:~$ sudo apt-get purge cowsay                                 
Reading package lists... Done                                                   
Building dependency tree                                                        
Reading state information... Done                                               
The following packages will be REMOVED:                                         
  cowsay*                                                                       
0 upgraded, 0 newly installed, 1 to remove and 0 not upgraded.                  
After this operation, 90.1 kB disk space will be freed.                         
Do you want to continue? [Y/n] y                                                
(Reading database ... 24377 files and directories currently installed.)         
Removing cowsay (3.03+dfsg1-6) ...                                              
Processing triggers for man-db (2.6.7.1-1ubuntu1) ...

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Atualizando senhas de usuário**

O comando passwd é usado para atualizar a senha de um usuário. Os usuários só podem alterar suas próprias senhas, enquanto o usuário root pode atualizar a senha para qualquer usuário.

passwd [OPÇÕES] [UTILIZADOR]

Por exemplo, uma vez que estamos conectados como o usuário sysadmin, podemos alterar a senha dessa conta. Execute o comando passwd. Você será solicitado a inserir a senha existente uma vez e a nova senha duas vezes. Por razões de segurança, nenhuma saída é exibida enquanto a senha está sendo digitada. A saída é mostrada da seguinte forma:

sysadmin@localhost:~$ passwd                                                    
Changing password for sysadmin.                                                 
(current) UNIX password: netlab123                                                       
Enter new UNIX password:                                                       
Retype new UNIX password:                                                       
passwd: password updated successfully

Se o usuário quiser exibir informações de status sobre sua senha, ele pode usar a opção -S:

sysadmin@localhost:~$ passwd -S sysadmin                                        
sysadmin P 12/20/2017 0 99999 7 -1

Os campos de saída são explicados abaixo:
Campo 	Exemplo 	Significado
User Name 	sysadmin 	O nome do usuário.
Password Status 	P 	

P indica uma senha utilizável.

L indica uma senha bloqueada.

NP indica que não há senha.
Change Date 	03/01/2015 	A data em que a senha foi alterada pela última vez.
Minimum 	0 	O número mínimo de dias que deve passar antes que a senha atual possa ser alterada pelo usuário.
Maximum 	99999 	O número máximo de dias restantes para a senha expirar.
Warn 	7 	O número de dias antes da expiração da senha que o usuário é avisado.
Inactive 	-1 	O número de dias após a expiração da senha que a conta do usuário permanece ativa.

Acompanhe

Alterne a conta root usando o seguinte comando. Use netlab123 como senha:

sysadmin@localhost:~$ su root                                                   
Password:                                                                       
root@localhost:~#

O usuário root pode alterar a senha de qualquer usuário. Se o usuário root quiser alterar a senha para sysadmin, ele executaria o seguinte comando:

root@localhost:~# passwd sysadmin                                               
Enter new UNIX password:                                                        
Retype new UNIX password:                                                       
passwd: password updated successfully

Acompanhe

Saia da conta root usando o comando exit:

root@localhost:~# exit                                                        
exit

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Redirecionamento**

Adicionar conteúdo a arquivos no Linux pode ser feito de várias maneiras. Linux tem alguns editores de texto que podem ser usados para adicionar conteúdo a um arquivo. No entanto, esse método requer alguma familiaridade com os comandos do editor de texto do Linux.

Nota

Editores de texto Linux são abordados na próxima seção deste curso.

Há uma maneira no Linux de adicionar rapidamente conteúdo a um arquivo usando um recurso de linha de comando chamado de redirecionamento de entrada/saída (I/O). O redirecionamento de E/S permite que as informações na linha de comando sejam enviadas para arquivos, dispositivos e outros comandos. A entrada ou saída de um comando é redirecionada de seu destino padrão para um local diferente. O redirecionamento de E/S é como uma série de trilhos de trem, onde um switch (interruptor) pode ser habilitado para direcionar a saída de um comando em uma faixa diferente para que ele vá para outro lugar no shell. Nesta seção, estamos escrevendo em arquivos redirecionando a saída de um comando para um arquivo.

Quando se trata de entrada de comando e saída existem três caminhos, ou 'trilhas'. Esses caminhos são chamados de descritores de arquivo. O primeiro descritor de arquivo é entrada padrão (standard input), abreviado como STDIN. A entrada padrão é a informação que o comando recebe e processa quando é executado, essencialmente o que um usuário digita no teclado. O segundo descritor de arquivo é a saída padrão (standard output), abreviado como STDOUT. Saída padrão é a informação que o comando exibe, a saída do comando. O último descritor de arquivo é erro padrão (standard error), abreviado como STDERR. STDERR, são as mensagens de erro geradas por comandos que não são executados corretamente. Veja a seguir exemplos de como os descritores de arquivos aparecerão no terminal:

Entrada padrão (STDIN)

sysadmin@localhost:~$ ls ~/Documents

Saída padrão (STDOUT)

sysadmin@localhost:~$ ls                                                        
Desktop  Documents  Downloads  Music  Pictures  Public  Templates  Videos

Erro padrão (STDERR)

sysadmin@localhost:~$ ls fakefile                                               
ls: cannot access fakefile: No such file or directory

Esta seção abordará um dos três descritores de arquivos, STDOUT, e como redirecionar STDOUT de onde você normalmente o vê, no terminal, para um arquivo no sistema de arquivos. Para usar o redirecionamento, basta usar um símbolo maior do que > junto com um nome de arquivo:

[COMANDO] > [ARQUIVO]

Para demonstrar o redirecionamento, usaremos a saída do comando cat. Sem redirecionamento, a saída do comando cat será exibida no terminal:

Acompanhe

Use o seguinte comando para alternar para o diretório Documents:

sysadmin@localhost:~$ cd ~/Documents

sysadmin@localhost:~/Documents$ cat food.txt                                    
Food is good.

Agora use o caractere > para redirecionar o STDOUT do comando cat food.txt acima para um novo arquivo chamado newfile1.txt:

sysadmin@localhost:~/Documents$ cat food.txt > newfile1.txt
sysadmin@localhost:~/Documents$

Como você pode ver, não há saída exibida desde que o STDOUT foi redirecionado para o arquivo newfile1.txt. Verifique se o STDOUT do comando cat food.txt está em newfile1.txt:

sysadmin@localhost:~/Documents$ cat newfile1.txt                     
Food is good.

Isso é útil se você precisar copiar conteúdo de um arquivo importante para outro arquivo para editar o conteúdo sem modificar o arquivo original. No entanto, e se você quiser adicionar um comentário ou nota a um arquivo? Para fazer isso, você pode usar o comando echo. O comando echo é usado para imprimir a saída no terminal:

sysadmin@localhost:~/Documents$ echo "Hello"           
Hello                                                                   
sysadmin@localhost:~/Documents$

Imprimir comentários na tela é um recurso divertido, mas o comando echo pode ser mais útil usando o redirecionamento. Usando o comando echo, o conteúdo pode ser adicionado ao arquivo newfile1.txt:

sysadmin@localhost:~/Documents$ cat newfile1.txt         
Food is good.     
sysadmin@localhost:~/Documents$ echo "I like food." > newfile1.txt
sysadmin@localhost:~/Documents$ cat newfile1.txt             
I like food.                                           
sysadmin@localhost:~/Documents$

Observe que o STDOUT do comando echo substituiu o conteúdo original do arquivo. Isso ocorre porque o único caractere > substituirá qualquer conteúdo em um arquivo existente. Para anexar em vez de sobrescrever/substituir conteúdo a um arquivo, use um símbolo duplo maior do que >>:

sysadmin@localhost:~/Documents$ echo "This food is good." >> newfile1.txt
sysadmin@localhost:~/Documents$ cat newfile1.txt              
I like food.                                                      
This food is good.                                 
sysadmin@localhost:~/Documents$

Importante

Para redirecionar informações para um arquivo existente, o usuário deve ter permissões de gravação nesse arquivo.

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Editor de Texto**

O principal editor de texto para Linux e UNIX é um programa chamado vi. Embora existam inúmeros editores disponíveis para Linux que vão desde o pequeno editor nano até o enorme editor emacs, existem várias vantagens para o editor vi:

    O editor vi está disponível em todas as distribuições Linux do mundo. Isto não é verdade para qualquer outro editor.

    O editor vi pode ser executado tanto em uma CLI (interface de linha de comando) quanto em uma GUI (interface gráfica do usuário).

    Embora novos recursos tenham sido adicionados ao editor vi, as funções principais já existem há décadas. Isso significa que se alguém aprendeu o editor vi na década de 1970, eles poderiam usar uma versão moderna sem qualquer problema. Embora pareça trivial, pode não parecer tão trivial daqui a 20 anos.

Considere o seguinte

A maneira correta de pronunciar o editor vi é o editor vee-eye. As letras vi representam visual, mas nunca foi pronunciado desta forma pelos desenvolvedores, mas sim a letra v seguida da letra i.

Na realidade, a maioria dos sistemas Linux não inclui o vi original, mas uma versão melhorada do mesmo conhecido como vim, para vi melhorado. Este fato pode estar oculto pela maioria das distribuições Linux. Na maioria das vezes, o vim funciona como vi, mas tem recursos adicionais. Para os tópicos que serão abordados neste curso, tanto vi como vim funcionarão.

Para começar a usar vi, basta digitar o comando seguido do nome do caminho para o arquivo para editar ou criar:

sysadmin@localhost:~$ vi newfile.txt

Existem três modos usados no vi: modo de comando, modo de inserção e modo ex.
Movimento do modo de comando

Inicialmente, o programa é iniciado no modo de comando. Modo de comando é usado para digitar comandos, como aqueles usados para se mover em torno de um documento, manipular texto e acessar os outros dois modos. Para retornar ao modo de comando a qualquer momento, pressione a tecla Esc.

Uma vez que algum texto foi adicionado a um documento, para executar ações como mover o cursor, a tecla Esc precisa ser pressionada primeiro para retornar ao modo de comando. Isso parece muito trabalho, mas lembre-se que vi funciona em um ambiente terminal onde um mouse é inútil.

Comandos de movimento em vi têm dois aspectos, um movimento e um prefixo numérico opcional, que indica quantas vezes repetir esse movimento. O formato geral é o seguinte:

[contagem] movimento

A tabela a seguir resume as teclas de movimento disponíveis:
Movimento 	Resultado
h 	Deixou um caractere
j 	Abaixo uma linha
k 	Acima uma linha
l 	Um caractere à direita
w 	Uma palavra para a frente
b 	Uma palavra atrás
^ 	Início da linha
$ 	Fim da linha

Nota

Desde a atualização para vim também é possível usar as teclas de seta ←↓↑→ em vez de hjkl respectivamente.

Esses movimentos podem ser prefixados com um número para indicar quantas vezes o movimento deve ser realizado. Por exemplo, 5h moverá o cursor cinco caracteres para a esquerda e 3w moverá o cursor três palavras para a direita.

Para mover o cursor para um número de linha específico, digite esse número de linha seguido do caractere G. Por exemplo, para chegar à quinta linha do arquivo tipo 5G. 1G ou gg pode ser usado para ir para a primeira linha do arquivo, enquanto um G solitário irá levá-lo para a última linha. Para descobrir em que linha o cursor está atualmente, use CTRL-G.
Ações do modo de comando

A convenção padrão para edição de conteúdo com processadores de texto é usar copiar, cortar e colar. O programa vi não tem nenhum destes. Em vez disso, vi usa os três comandos a seguir:
Padrão 	Vi 	Significado
cut 	d 	deletar
copy 	y 	copiar
paste 	P | p 	colar

Os movimentos aprendidos na página anterior são usados para especificar onde a ação deve ocorrer, sempre começando com a localização atual do cursor. Qualquer um dos seguintes formatos gerais para comandos de ação é aceitável:

açao [contagem] movimento

[contagem] movimento ação

Excluir

Excluir remove o texto indicado da página e o guarda no buffer, sendo o buffer o equivalente à “área de transferência” usada no Windows ou Mac OSX. A tabela a seguir fornece alguns exemplos de uso comuns:
Ação 	Resultado
dd 	Excluir linha atual
3dd 	Excluir as próximas três linhas
dw 	Excluir a palavra atual
d3w 	Excluira as próximas três palavras
d4h 	Excluir quatro caracteres à esquerda
Mudar

Mudança é muito semelhante a excluir; o texto é removido e guardado no buffer, no entanto, o programa é alternado para o modo de inserção para permitir alterações imediatas no texto. A tabela a seguir fornece alguns exemplos de uso comuns:
Ação 	Resultado
cc 	Mudar linha atual
cw 	Mudar palavra atual
c3w 	Mudar as próximas três palavras
c5h 	Mudar cinco caracteres para a esquerda
Arrancar (Yank)

Yank coloca conteúdo no buffer sem excluí-lo. A tabela a seguir fornece alguns exemplos de uso comuns:
Ação 	Resultado
yy 	Arranque a linha atual
3yy 	Arranque as próximas três linhas
yw 	Arranque as próximas três linhas
y$ 	Arranque até o fim da linha
Colocar

O colocar, posiciona o texto guardado no buffer antes ou depois da posição do cursor. Observe que estas são as duas únicas opções, o colocar não usa os movimentos como os comandos de ação anteriores.
Ação 	Resultado
p 	Colocar (colar) após o cursor
P 	Colocar antes do cursor
Pesquisando em vi

Outra função padrão que os processadores de texto oferecem é o encontrar. Muitas vezes, as pessoas usam CTRL-F ou observam o menu de edição. O programa vi usa a pesquisa. O pesquisar é mais eficiente do que o encontrar porque suporta padrões de texto literal e expressões regulares.

Para pesquisar a partir da posição atual do cursor, use / para iniciar a pesquisa, digite um termo de pesquisa e pressione a tecla Enter para iniciar a pesquisa. O cursor se moverá para a primeira correspondência que for encontrada.

Para prosseguir para a próxima correspondência usando o mesmo padrão, pressione a tecla n. Para voltar a uma partida anterior, pressione a tecla N. Se o fim ou o início do documento for atingido, a pesquisa se estenderá automaticamente para o outro lado do documento.

Para começar a pesquisar para trás a partir da posição do cursor, comece esc revendo ?, depois digite o padrão para procurar correspondências e pressione a tecla Enter.
Modo de inserção

O modo de inserção é usado para adicionar texto ao documento. Há algumas maneiras de entrar no modo de inserção a partir do modo de comando, cada uma diferenciada por onde a inserção de texto começará. A tabela a seguir abrange o mais comum:
Entrada 	Objetivo
a 	Entrar no modo de inserção logo após o cursor
A 	Entrar no modo de inserção no final da linha
i 	Entrar no modo de inserção logo antes do cursor
I 	Entrar no modo de inserção no início da linha
o 	Entrar no modo de inserção em uma linha em branco após o cursor
O 	Entrar no modo de inserção em uma linha em branco antes do cursor
Ex Mode

Originalmente, o editor vi era chamado de editorex. O nome vi era a abreviação do comando visual no editor ex que mudou o editor para o modo “visual”.

No modo normal original, o editor ex só permitia aos usuários ver e modificar uma linha de cada vez. No modo visual, os usuários podiam ver o máximo possível do documento que caberia na tela. Como a maioria dos usuários preferia o modo visual ao modo de edição de linha, o arquivo ex programa foi vinculado a um arquivo vi, para que os usuários pudessem iniciar ex diretamente no modo visual quando executassem o link vi.

Eventualmente, o arquivo de programa real foi renomeado vi e o editor ex tornou-se um link que apontava o editor vi.

Quando o modo ex do editor vi está sendo usado, é possível visualizar ou alterar configurações, bem como executar comandos relacionados a arquivos, como abrir, guardar ou interromper alterações em um arquivo. Para chegar ao modo ex, digite um caractere : no modo de comando. A tabela a seguir lista algumas ações comuns executadas no modo ex:
Entrada 	Objetivo
:w 	Salvar o arquivo atual no sistema de arquivos
:w nome_do_arquivo 	Salvar uma cópia do arquivo atual como nome_do_arquivo
:w! 	Forçar salvar arquivo atual
:1 	Vá para a linha número 1 ou qualquer número fornecido
:e nome_do_arquivo 	Abrir nome_do_arquivo
:q 	Sair se nenhuma alteração for feita no arquivo
:q! 	Sair sem salvar as alterações no arquivo

Uma análise rápida da tabela acima revela que, se um ponto de exclamação, !, é adicionado a um comando, ele então tenta forçar a operação. Por exemplo, imagine que você faz alterações em um arquivo no editor vi e, em seguida, tente sair com :q, apenas para descobrir que o comando falha. O editor vi não quer sair sem salvar as alterações feitas em um arquivo, mas você pode forçá-lo a sair com o comando ex :q!.

Considere o seguinte

Embora o modo ex ofereça várias maneiras de salvar e sair, também há ZZ que está disponível no modo de comando; este é o equivalente a :wq. Existem muitas mais funções sobrepostas entre o modo ex e o modo de comando. Por exemplo, o modo ex pode ser usado para navegar para qualquer linha no documento, digitando : seguido do número da linha, enquanto o G pode ser usado no modo de comando como demonstrado anteriormente.

Acompanhe

Se você tiver um arquivo de texto aberto, saia dele executando o :q! comando. Isso será encerrado sem salvar as alterações.

~
~
:q!_

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Avançar**

Esperamos que você tenha gostado desta breve introdução ao mundo do Linux. O conteúdo contido aqui se alinha ao conhecimento de Linux abrangido pelos objetivos do exame LPI Linux Essentials, mas há muito mais! Obtenha conhecimentos de Linux de nível de certificação para avançar sua carreira!
NDG Linux Essentials

Se você estiver interessado em ampliar seu conhecimento em Linux, a Cisco Networking Academy também oferece três cursos em Linux. O NDG Linux Essentials é perfeito para iniciantes que procuram compreender o básico, enquanto o NDG Linux Series oferece aos iniciantes uma cobertura mais rigorosa e aprofundada.
NDG Linux Essentials. Aprenda os fundamentos do sistema operacional Linux, linha de comando e conceitos básicos de código aberto. Imagem de alunos olhando para monitores.

O curso NDG Linux Essentials foi projetado para prepará-lo para o Certificado de Desenvolvimento Profissional Linux Essentials do Linux, que valida uma compreensão demonstrada de:

    FOSS, as várias comunidades e licenças
    Conhecimento de aplicativos de código aberto no local de trabalho, uma vez que se relacionam com equivalentes de código fechado
    Conceitos básicos de hardware, processos, programas e componentes do sistema operativo Linux
    Como trabalhar na linha de comando e com arquivos
    Como criar e restaurar backups e arquivos compactados
    Segurança do sistema, usuários/grupos e permissões de arquivo para diretórios públicos e privados
    Como criar e executar scripts simples

Para obter o Certificado de Desenvolvimento Profissional do Linux Essentials, você deve passar o Linux Essentials (LPI-010) que abrange:

    A comunidade Linux e uma carreira em código aberto
    Encontrando seu caminho em um sistema Linux
    O poder da linha de comando
    O sistema operativo Linux
    Segurança e permissões de arquivo

O Certificado de Desenvolvimento Profissional do Linux Essentials é o início do seu caminho para se tornar um profissional certificado pelo Linux. Informações sobre as certificações do Linux Professional Institute podem ser encontradas acessando http://www.lpi.org.

Não se preocupe se você tem pouca ou nenhuma experiência no Linux. Este curso é o local de partida perfeito projetado para ensinar todos os conceitos da estaca zero. No entanto, se você não achar este material desafiador o suficiente, considere começar com o NDG Introdução ao Linux I, um curso introdutório mais rigoroso.
NDG Linux Series
NDG Linux I and II. Aprenda habilidades de administração de sistema Linux e prepare-se para LPI LPIC-1 ou CompTIA Linux + com certificação LPI. Imagem de dois estudantes do sexo masculino olhando para um monitor.

A série NDG Linux foi projetada para prepará-lo para a certificação Linux Professional Institute Nível 1. LPIC-1 é uma certificação Linux Server Professional para administradores Linux que confirma sua capacidade de realizar as seguintes tarefas:

    Trabalhar na linha de comando do Linux
    Executar tarefas fáceis de manutenção: ajudar os usuários, adicionar usuários a um sistema maior, fazer backup e restaurar, desligar e reiniciar.
    Instalar e configurar uma estação de trabalho (incluindo X) e conectá-la a uma LAN ou a um PC autônomo na Internet.

Para obter a certificação LPIC-1, você deve passar nos Exames 101 e 102. A introdução ao Linux I da NDG foi projetada para prepará-lo para o Exame 101, que abrange:

    Arquitetura do sistema
    Instalação do Linux e gerenciamento de pacotes
    GNU and Unix Commands
    Dispositivos, sistemas de arquivos Linux, hierarquia de sistemas de arquivos padrãos

A introdução ao Linux II da NDG alinha-se aos objetivos do Exame 102, que abrange:

    Shell, Script e Gerenciamento de Dados
    Interfaces e áreas de trabalho
    Tarefas administrativas
    Serviços Essenciais do Sistema
    Fundamentos de rede
    Segurança

A certificação LPIC-1 é a primeira de três certificações profissionais LPI. Informações sobre todas as certificações do Linux Professional Institute estão disponíveis em: http://www.lpi.org.
IT Essentials

Para saber mais sobre as habilitações fundamentais em informática e carreira para empregos de TI de nível básico, confira o restante do IT Essentials.
IT Essentials. Aprenda a construir e configurar um computador e conectá-lo com segurança a uma rede, seu primeiro passo para uma carreira em TI. Alunos olhando para o interior de um computador.

O IT Essentials cobre as habilitações fundamentais em informática e carreira para empregos de nível básico de TI. O currículo IT Essentials inclui laboratórios práticos que oferecem experiência prática. As ferramentas virtuais ajudam você a aprimorar suas capacidades de resolução de problemas e praticar o que você aprende.

    Desenvolver conhecimento prático de como os computadores funcionam
    Desenvolver o pensamento crítico e capacidades complexas de solução de problemas usando laboratórios práticos e ferramentas virtuais de aprendizagem
    Aplicar habilitações e procedimentos para instalar e atualizar hardware e software e sistemas de resolução de problemas
    Praticar o que aprendeu em equipamentos reais e usando a ferramenta de simulação Cisco Packet Tracer
    Receber feedback imediato sobre seu trabalho através de testes e testes integrados
    Conectare com a comunidade global da Cisco Networking Academy

-------------------------------------------------------------------------------------------------------------------------------------------------------

 **Linux para Cisco Certified CyberOps Associate**

Parabéns por ter terminado este curto curso introdutório Linux! Você acabou de aprender muitos conceitos do Linux que podem ajudá-lo a ir mais longe em sua jornada de TI. Destacamos que o Linux está em toda parte. Também enfatizamos que aprender Linux é benéfico para uma grande variedade de carreiras tecnológicas. Você pode considerar continuar seus estudos de TI em uma variedade de áreas, incluindo redes, IoT e uma das especialidades de TI mais exigentes atualmente, cibersegurança.

Um dos desafios mais importantes que enfrentamos em nosso universo digital hoje é a cibersegurança. Há uma quantidade crescente de dispositivos inteligentes que podem ser conectados a redes, o que é conveniente para usuários que desejam permanecer conectados. No entanto, isso também pode tornar as redes vulneráveis a indivíduos e organizações que estão tentando obter acesso malicioso a dispositivos e redes. Como resultado, o campo da cibersegurança está crescendo e, nos últimos anos, o treinamento de profissionais de cibersegurança tornou-se uma prioridade para as instituições de tecnologia da informação.

A Cisco Network Academy desenvolveu um programa de certificação para preparar indivíduos interessados em uma carreira de cibersegurança. A certificação Cisco Certified CyberOps Associate foi projetada para fornecer conhecimento das tarefas específicas esperadas para monitorar sistemas de informação. Com isso em mente, se você está apenas começando seus estudos de TI ou se estiver interessado em explorar caminhos em TI, talvez valha a pena notar que há uma demanda por profissionais treinados no Cisco Certified CyberOps Associate.
Seja a arma de segurança cibernética de TI da sua empresa. Cursos NDG Linux, a maneira inteligente de se preparar para Cisco Certified CyberOps Associate.

"Seja a arma de segurança cibernética de TI da sua empresa. Cursos NDG Linux, a maneira inteligente de se preparar para Cisco Certified CyberOps Associate"

A melhor parte é que as habilitações básicas em Linux abordadas neste curso podem ser aplicadas, juntamente com treinamento adicional, a uma trilha de aprendizado Cisco Certified CyberOps Associate. O aprendizado de habilidades básicas do Linux pode melhorar a capacidade de executar tarefas específicas no treinamento Cisco Certified CyberOps Associate, bem como compreender conceitos e objetivos ensinados no curso Cisco Certified CyberOps Associate.

Considere que, ao aprender a monitorar e detectar ameaças, os alunos do Cisco Certified CyberOps Associate devem aprender sobre diferentes sistemas operativos e como solucionar problemas e analisar esses sistemas operativos. Como o Linux é usado em dispositivos móveis, servidores e máquinas de clientes, é importante aprender a navegar pelo sistema operativo Linux. Por esse motivo, a análise de servidores executando o Linux compõe muitos dos objetivos de aprendizado da Cisco Certified CyberOps Associate.

A compreensão do Linux permite que os alunos de cibersegurança analisem forensicamente o sistema de arquivos Linux, monitorar servidores Linux, bem como máquinas de clientes, dispositivos e outras tecnologias executando Linux. Alguns dos comandos e ferramentas abordados neste curso são requisitos básicos para as habilitações mencionadas acima. A tabela abaixo destaca como o que você aprendeu neste curso é benéfico para uma faixa de aprendizado Cisco Certified CyberOps Associate:
Objetivos de Aprendizagem do Linux Unhatched Habilitações do adquiridas no Cisco Certified CyberOps Associate Listagem de arquivos Visualização de arquivos Filtragem de entrada Padrões básicos Redirecionamento Análise de Arquivos Visualização de arquivos Cópia de arquivos Redirecionamento Editores de texto Permissões de arquivo Mudança de propriedade do arquivo Manipulação de Arquivos Editores de Texto Modificando e criando arquivos de configuração Permissões de arquivo Permissões de usuário e grupo Acesso administrativo Atualização de senhas de usuário Permissões Configuração de rede Configuração de rede

Neste curso, você aprendeu sobre a execução de operações básicas do Linux, tarefas administrativas e relacionadas à segurança. Os profissionais de cibersegurança precisam saber como executar essas tarefas em vários sistemas operativos, incluindo Windows, macOS e Linux. Os cursos NDG Linux são projetados para ensinar uma variedade de comandos, termos e utilitários que ajudarão a prepará-lo para uma carreira em cibersegurança. Confira abaixo alguns dos comandos do Linux necessários para Cisco Certified CyberOps Associate abaixo:
Comandos Linux para Cisco Certified CyberOps Associate. Os comandos incluem apt, cat, cd, ls, sudo, tail, ssh e muito mais!

"Comandos Linux para Cisco Certified CyberOps Associate. Os comandos incluem apt, cat, cd, ls, sudo, tail, ssh e muito mais!"

Para saber mais sobre Linux e comandos e utilitários para criar uma base de conhecimento do Linux para ajudá-lo a ir mais longe no treinamento que é benéfico para uma faixa de aprendizado Cisco Certified CyberOps Associate, consulte outros cursos do NDG Linux. Para saber mais sobre o curso Cisco Certified CyberOps Associate, clique aqui.
